<!DOCTYPE html><html><head>
	<title>Structs – ammer manual</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="css/style.css" media="all">
	<link rel="stylesheet" href="css/highlight.css" media="all">
	<script src="search.js"></script>
</head><body>
	<header><a href="index.html"><h1>ammer</h1></a></header>
	<nav id="menu">
		<input autocomplete="off" tabindex="0" title="Click here to search" id="search" type="text" placeholder="Enter search term here">
		<label for="search"></label>
		<div class="menu-split"></div>
		<div class="menu-split show"><ul><li><a href="index.html">Introduction</a></li><ul><li><a href="intro-overview.html">Overview</a></li></ul><ul><li><a href="intro-terminology.html">Terminology</a></li></ul><ul><li><a href="intro-use.html">Why <code>ammer</code>?</a></li></ul><ul><li><a href="intro-installation.html">Installation</a></li></ul><ul><li><a href="intro-start.html">Getting started</a></li></ul></ul><ul><li><a href="definition.html">Definition</a></li><ul><li><a href="definition-library.html">Library definition</a></li><ul><li><a href="definition-library-functions.html">Functions</a></li></ul><ul><li><a href="definition-library-variables.html">Variables</a></li></ul><ul><li><a href="definition-sub.html">Sublibraries</a></li></ul></ul><ul><li><a href="definition-type.html">Datatypes</a></li><ul><li><a href="definition-type-opaque.html">Opaque types</a></li></ul><ul><li><a href="definition-type-struct.html">Structs</a></li></ul><ul><li><a href="definition-type-instance.html">Instance methods</a></li></ul><ul><li><a href="definition-type-enum.html">Enums</a></li></ul><ul><li><a href="definition-type-haxe.html">Haxe types</a></li></ul><ul><li><a href="definition-type-callbacks.html">Callbacks</a></li></ul><ul><li><a href="definition-link.html">Linking subdefinitions</a></li></ul></ul></ul><ul><li><a href="configuration.html">Configuration</a></li><ul><li><a href="configuration-providing.html">Providing flags</a></li></ul><ul><li><a href="configuration-project.html">Project-wide configuration</a></li></ul><ul><li><a href="configuration-library.html">Library configuration</a></li></ul></ul><ul><li><a href="target.html">Target details</a></li><ul><li><a href="target-feature-parity.html">Feature parity</a></li></ul><ul><li><a href="target-hxcpp.html">C++</a></li></ul><ul><li><a href="target-cs.html">C#</a></li></ul><ul><li><a href="target-eval.html">Eval</a></li></ul><ul><li><a href="target-hashlink.html">HashLink</a></li></ul><ul><li><a href="target-java.html">Java</a></li></ul><ul><li><a href="target-lua.html">Lua</a></li></ul><ul><li><a href="target-neko.html">Neko</a></li></ul><ul><li><a href="target-nodejs.html">Node.js</a></li></ul><ul><li><a href="target-python.html">Python</a></li></ul></ul><ul><li><a href="ref.html">Reference</a></li><ul><li><a href="ref-ffi.html">FFI types</a></li></ul><ul><li><a href="ref-def.html"><code>ammer.def.*</code> types</a></li></ul><ul><li><a href="ref-lib.html"><code>ammer.Lib</code></a></li></ul><ul><li><a href="ref-flags.html">List of configuration flags</a></li></ul><ul><li><a href="ref-annot.html">List of annotations</a></li></ul></ul><ul><li><a href="amlib.html"><code>amlib</code></a></li></ul><ul><li><a href="advanced.html">Advanced topics</a></li><ul><li><a href="advanced-cycles.html">Type cycles</a></li></ul></ul><ul><li><a href="core.html"><code>ammer-core</code></a></li><ul><li><a href="core-api.html">Interface</a></li></ul><ul><li><a href="core-new-platform.html">Implementing new platforms</a></li></ul></ul></div>
	</nav>
	<main><h2>Structs</h2><p>When a struct type is not <a href="definition-type-opaque.html" title="Opaque types">opaque</a>, its fields are known and can be read and written directly, without using a library method.</p>
<p>To define a struct type, extend <code>ammer.def.Struct&lt;..., ...&gt;</code> with a Haxe class. The first type parameter for <code>ammer.def.Struct</code> should be a string identifying the native C type name. The second type parameter should be the <code>ammer</code> library this type belongs to.</p>
<p>Struct definitions can contain <a href="#variables" title="Variables">variable fields</a>, as well as <a href="definition-type-instance.html" title="Instance methods">instance methods</a>.</p>
<div class="example">

<h3>Example: library datatype definition</h3><div class="hl"><pre><i class="hl-kw">class</i><i class="hl-other"> </i><i class="hl-decl">FoobarStruct</i><i class="hl-other"> </i><i class="hl-kw">extends</i><i class="hl-other"> </i><a class="hll-ty" href="ref-def.html#struct" title="ammer.def.* types / ammer.def.Struct"><i class="hl-ty">ammer</i><i class="hl-tyx">.</i><i class="hl-ty">def</i><i class="hl-tyx">.</i><i class="hl-ty">Struct</i></a><i class="hl-tyx">&lt;</i><i class="hl-lit">"struct foobar_s"</i><i class="hl-tyx">,</i><i class="hl-other"> </i><i class="hl-ty">Foobar</i><i class="hl-tyx">&gt;</i><i class="hl-other"> {
  </i><i class="hl-com">// ...</i><i class="hl-other">
}</i></pre></div><p>In this example, <code>FoobarStruct</code> is a struct in the <code>Foobar</code> library. The C name for this struct is <code>struct foobar_s</code>. Values of <code>FoobarStruct</code> in Haxe represent instances of <code>struct foobar_s*</code> (a <em>pointer</em> to <code>struct foobar_s</code>).</p>
</div>

<h3 id="pointer">Instances are pointers</h3><p>Note that on the Haxe side, any struct value will be represented as a pointer to a struct. This is because most <code>ammer</code> targets do not support arbitrarily large stack-allocated data. See <a href="#deref" title="Passing structs directly">passing structs directly</a> for declaring APIs which do not use a pointer indirection.</p>
<h3 id="variables">Variables</h3><p>Structs definitions can contain variables, declared as <code>public var</code> or <code>var</code> fields.</p>
<div class="example">

<h3>Example: struct variables</h3><div class="hl"><pre><i class="hl-kw">class</i><i class="hl-other"> </i><i class="hl-decl">FoobarStruct</i><i class="hl-other"> </i><i class="hl-kw">extends</i><i class="hl-other"> </i><a class="hll-ty" href="ref-def.html#struct" title="ammer.def.* types / ammer.def.Struct"><i class="hl-ty">ammer</i><i class="hl-tyx">.</i><i class="hl-ty">def</i><i class="hl-tyx">.</i><i class="hl-ty">Struct</i></a><i class="hl-tyx">&lt;</i><i class="hl-lit">"struct foobar_s"</i><i class="hl-tyx">,</i><i class="hl-other"> </i><i class="hl-ty">Foobar</i><i class="hl-tyx">&gt;</i><i class="hl-other"> {
  </i><i class="hl-kw">public</i><i class="hl-other"> </i><i class="hl-kw">var</i><i class="hl-other"> </i><i class="hl-decl">bar</i><i class="hl-tyx">:</i><i class="hl-ty">Int</i><i class="hl-other">;
}</i></pre></div><p>In this example <code>FoobarStruct</code> has a <code>bar</code> variable that can be read or written:</p>
<div class="hl"><pre><i class="hl-kw">var</i><i class="hl-other"> </i><i class="hl-decl">x</i><i class="hl-tyx">:</i><i class="hl-ty">FoobarStruct</i><i class="hl-other"> </i><i class="hl-op">=</i><i class="hl-other"> </i><i class="hl-dummy">#dummy expr</i><i class="hl-com">/*...*/</i><i class="hl-other">;
x</i><i class="hl-op">.</i><i class="hl-other">bar </i><i class="hl-op">=</i><i class="hl-other"> </i><i class="hl-lit">3</i><i class="hl-other">;
</i><i class="hl-kw">var</i><i class="hl-other"> </i><i class="hl-decl">y</i><i class="hl-other"> </i><i class="hl-op">=</i><i class="hl-other"> x</i><i class="hl-op">.</i><i class="hl-other">bar;</i></pre></div></div>

<p>Variables map to pointer accesses in C code, so a <code>bar</code> variable is read as <code>(someStruct)-&gt;bar</code> and written as <code>(someStruct)-&gt;bar = value</code>. Note that any read or write variable access may have a runtime cost of a function call.</p>
<h3 id="alloc">Allocation and deallocation</h3><p>To make it possible to allocate and deallocate a struct, it must be marked with the <a href="ref-annot.html#alloc" title="List of annotations / @:ammer.alloc"><code>@:ammer.alloc</code></a> metadata. When annotated, several functions are made available:</p>
<ul>
<li><a href="ref-lib.html#allocstruct" title="ammer.Lib / ammer.Lib.allocStruct method"><code>alloc</code></a> — a static function which allocates an instance of the given struct type. Initial values for its fields can optionally be passed using an object syntax.</li>
<li><a href="ref-lib.html#freestruct" title="ammer.Lib / ammer.Lib.freeStruct method"><code>free</code></a> — an instance method which deallocates the underlying allocation.</li>
<li><a href="ref-lib.html#nullptrstruct" title="ammer.Lib / ammer.Lib.nullPtrStruct method"><code>nullPtr</code></a> — a static function which returns a null pointer of the given struct type.</li>
</ul>
<p>The name of the generated functions can be changed to avoid conflicts with other functions. <a href="ref-annot.html#alloc" title="List of annotations / @:ammer.alloc"><code>@:ammer.alloc</code></a> is simply a convenience shortcut to the combination <a href="ref-annot.html#gen.alloc" title="List of annotations / @:ammer.gen.alloc"><code>@:ammer.gen.alloc(&quot;alloc&quot;)</code></a>, <a href="ref-annot.html#gen.free" title="List of annotations / @:ammer.gen.free"><code>@:ammer.gen.free(&quot;free&quot;)</code></a>, <a href="ref-annot.html#gen.nullptr" title="List of annotations / @:ammer.gen.nullPtr"><code>@:ammer.gen.nullPtr(&quot;nullPtr&quot;)</code></a>, where the string arguments specify the name of each generated method.</p>
<div class="example">

<h3>Example: allocating and deallocating a struct</h3><p>Given a struct definition annotated with <a href="ref-annot.html#alloc" title="List of annotations / @:ammer.alloc"><code>@:ammer.alloc</code></a>:</p>
<div class="hl"><pre><a class="hll-meta" href="ref-annot.html#alloc" title="List of annotations / @:ammer.alloc"><i class="hl-metax">@:</i><i class="hl-meta">ammer</i><i class="hl-metax">.</i><i class="hl-meta">alloc</i></a><i class="hl-other">
</i><i class="hl-kw">class</i><i class="hl-other"> </i><i class="hl-decl">FoobarStruct</i><i class="hl-other"> </i><i class="hl-kw">extends</i><i class="hl-other"> </i><a class="hll-ty" href="ref-def.html#struct" title="ammer.def.* types / ammer.def.Struct"><i class="hl-ty">ammer</i><i class="hl-tyx">.</i><i class="hl-ty">def</i><i class="hl-tyx">.</i><i class="hl-ty">Struct</i></a><i class="hl-tyx">&lt;</i><i class="hl-lit">"struct foobar_s"</i><i class="hl-tyx">,</i><i class="hl-other"> </i><i class="hl-ty">Foobar</i><i class="hl-tyx">&gt;</i><i class="hl-other"> {
  </i><i class="hl-kw">public</i><i class="hl-other"> </i><i class="hl-kw">var</i><i class="hl-other"> </i><i class="hl-decl">some_field</i><i class="hl-tyx">:</i><i class="hl-ty">Int</i><i class="hl-other">;
}</i></pre></div><p>It can be allocated by calling <code>alloc</code>:</p>
<div class="hl"><pre><i class="hl-com">// with fields zeroed out:</i><i class="hl-other">
</i><i class="hl-kw">var</i><i class="hl-other"> </i><i class="hl-decl">x</i><i class="hl-other"> </i><i class="hl-op">=</i><i class="hl-other"> FoobarStruct</i><i class="hl-op">.</i><i class="hl-other">alloc();
</i><i class="hl-com">// or with some initial values:</i><i class="hl-other">
</i><i class="hl-kw">var</i><i class="hl-other"> </i><i class="hl-decl">x</i><i class="hl-other"> </i><i class="hl-op">=</i><i class="hl-other"> FoobarStruct</i><i class="hl-op">.</i><i class="hl-other">alloc({
  </i><i class="hl-tyx">some_field</i><i class="hl-op">:</i><i class="hl-other"> </i><i class="hl-lit">42</i><i class="hl-other">,
});</i></pre></div><p>It can then be deallocated:</p>
<div class="hl"><pre><i class="hl-other">x</i><i class="hl-op">.</i><i class="hl-other">free();</i></pre></div><p>And a null pointer can be obtained:</p>
<div class="hl"><pre><i class="hl-kw">var</i><i class="hl-other"> </i><i class="hl-decl">x</i><i class="hl-other"> </i><i class="hl-op">=</i><i class="hl-other"> FoobarStruct</i><i class="hl-op">.</i><i class="hl-other">nullPtr();</i></pre></div></div>

<h3 id="deref">Passing structs directly</h3><p>Native methods which take a struct directly, as opposed to a pointer to a struct, can be declared by using the special <code>ammer.ffi.Deref&lt;...&gt;</code> type. This dereferences the struct pointer just before the native method call.</p>
<div class="example">

<h3>Example: using <code>ammer.ffi.Deref</code></h3><div class="hl"><pre><i class="hl-kw">class</i><i class="hl-other"> </i><i class="hl-decl">Foobar</i><i class="hl-other"> {
  </i><i class="hl-kw">public</i><i class="hl-other"> </i><i class="hl-kw">static</i><i class="hl-other"> </i><i class="hl-kw">function</i><i class="hl-other"> </i><i class="hl-decl">take_struct_ptr</i><i class="hl-other">(</i><i class="hl-decl">x</i><i class="hl-tyx">:</i><i class="hl-ty">FoobarStruct</i><i class="hl-other">)</i><i class="hl-tyx">:</i><i class="hl-ty">Void</i><i class="hl-other">;
  </i><i class="hl-kw">public</i><i class="hl-other"> </i><i class="hl-kw">static</i><i class="hl-other"> </i><i class="hl-kw">function</i><i class="hl-other"> </i><i class="hl-decl">take_struct_val</i><i class="hl-other">(</i><i class="hl-decl">x</i><i class="hl-tyx">:</i><i class="hl-ty">ammer</i><i class="hl-tyx">.</i><i class="hl-ty">ffi</i><i class="hl-tyx">.</i><i class="hl-ty">Deref</i><i class="hl-tyx">&lt;</i><i class="hl-ty">FoobarStruct</i><i class="hl-tyx">&gt;</i><i class="hl-other">)</i><i class="hl-tyx">:</i><i class="hl-ty">Void</i><i class="hl-other">;
}</i></pre></div><p>This example demonstrates passing a struct using a pointer and passing it directly. The corresponding C signatures could look like this:</p>
<div class="hl"><pre><i>void take_struct_ptr(struct foobar_s* x) { /*...*/ }
void take_struct_val(struct foobar_s x) { /*...*/ }</i></pre></div><p>Note that on the Haxe call side, the two methods are called the same way: by passing an instance of the <code>FoobarStruct</code> type. The dereferencing, if any, happens transparently.</p>
<div class="hl"><pre><i class="hl-kw">var</i><i class="hl-other"> </i><i class="hl-decl">x</i><i class="hl-tyx">:</i><i class="hl-ty">FoobarStruct</i><i class="hl-other"> </i><i class="hl-op">=</i><i class="hl-other"> </i><i class="hl-dummy">#dummy expr</i><i class="hl-com">/*...*/</i><i class="hl-other">;
Foobar</i><i class="hl-op">.</i><i class="hl-other">take_struct_ptr(x);
Foobar</i><i class="hl-op">.</i><i class="hl-other">take_struct_val(x);</i></pre></div></div>

<p>A similar situation arises when a native library method returns a struct value. To obtain a pointer to the struct, a heap allocation must take place to store that struct. In <code>ammer</code>, return types can be wrapped with the special <code>ammer.ffi.Alloc&lt;...&gt;</code> type to achieve this.</p>
<div class="example">

<h3>Example: using <code>ammer.ffi.Alloc</code></h3><div class="hl"><pre><i class="hl-kw">class</i><i class="hl-other"> </i><i class="hl-decl">Foobar</i><i class="hl-other"> {
  </i><i class="hl-kw">public</i><i class="hl-other"> </i><i class="hl-kw">static</i><i class="hl-other"> </i><i class="hl-kw">function</i><i class="hl-other"> </i><i class="hl-decl">give_struct_ptr</i><i class="hl-other">()</i><i class="hl-tyx">:</i><i class="hl-ty">FoobarStruct</i><i class="hl-other">;
  </i><i class="hl-kw">public</i><i class="hl-other"> </i><i class="hl-kw">static</i><i class="hl-other"> </i><i class="hl-kw">function</i><i class="hl-other"> </i><i class="hl-decl">give_struct_val</i><i class="hl-other">()</i><i class="hl-tyx">:</i><i class="hl-ty">ammer</i><i class="hl-tyx">.</i><i class="hl-ty">ffi</i><i class="hl-tyx">.</i><i class="hl-ty">Alloc</i><i class="hl-tyx">&lt;</i><i class="hl-ty">FoobarStruct</i><i class="hl-tyx">&gt;</i><i class="hl-other">;
}</i></pre></div><p>This example demonstrates a native method returning a pointer to a struct and one returning a struct directly. The corresponding C signatures could look like this:</p>
<div class="hl"><pre><i>struct foobar_s* give_struct_ptr() { /*...*/ }
struct foobar_s give_struct_val() { /*...*/ }</i></pre></div><p>Note that on the Haxe call side, the two methods have the same return type: an instance of <code>FoobarStruct</code>. The allocation, if any, happens transparently.</p>
<div class="hl"><pre><i class="hl-kw">var</i><i class="hl-other"> </i><i class="hl-decl">x</i><i class="hl-tyx">:</i><i class="hl-ty">FoobarStruct</i><i class="hl-other"> </i><i class="hl-op">=</i><i class="hl-other"> Foobar</i><i class="hl-op">.</i><i class="hl-other">give_struct_ptr();
</i><i class="hl-kw">var</i><i class="hl-other"> </i><i class="hl-decl">y</i><i class="hl-tyx">:</i><i class="hl-ty">FoobarStruct</i><i class="hl-other"> </i><i class="hl-op">=</i><i class="hl-other"> Foobar</i><i class="hl-op">.</i><i class="hl-other">give_struct_val();</i></pre></div></div>

<h3>Linking</h3><p>Structs should be linked with the parent library using the <a href="ref-annot.html#sub" title="List of annotations / @:ammer.sub"><code>@:ammer.sub(...)</code></a> metadata to avoid compilation errors. See <a href="definition-link.html" title="Linking subdefinitions">linking subdefinitions</a>.</p>
<h3>Metadata applicable to structs</h3><ul>
<li><a href="ref-annot.html#alloc" title="List of annotations / @:ammer.alloc"><code>@:ammer.alloc</code></a></li>
<li><a href="ref-annot.html#nativeprefix" title="List of annotations / @:ammer.nativePrefix"><code>@:ammer.nativePrefix</code></a></li>
<li><a href="ref-annot.html#sub" title="List of annotations / @:ammer.sub"><code>@:ammer.sub</code></a></li>
<li><a href="ref-annot.html#gen.alloc" title="List of annotations / @:ammer.gen.alloc"><code>@:ammer.gen.alloc</code></a></li>
<li><a href="ref-annot.html#gen.free" title="List of annotations / @:ammer.gen.free"><code>@:ammer.gen.free</code></a></li>
<li><a href="ref-annot.html#gen.nullptr" title="List of annotations / @:ammer.gen.nullPtr"><code>@:ammer.gen.nullPtr</code></a></li>
</ul>
</main>
	<a id="page-prev" href="definition-type-opaque.html">« Previous: Opaque types</a>
	<a id="page-next" href="definition-type-instance.html">Next: Instance methods »</a>
	<footer>
		<a href="https://github.com/Aurel300/ammer/blob/gh-pages-src/content/02-definition.md?plain=1#L268">Contribute to this page</a>
		| <a href="https://github.com/Aurel300/ammer/" target="_blank"><code>ammer</code> on GitHub</a>
		| &copy; 2019-2023 Aurel Bílý
	</footer>
</body></html>