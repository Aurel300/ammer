<!DOCTYPE html><html><head>
	<title>Library datatype definition – ammer manual</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="css/style.css" media="all">
</head><body>
	<header><a href="index.html"><h1>ammer</h1></a></header>
	<nav id="menu"><ul><li><a href="index.html">Introduction</a></li><ul><li><a href="intro-start.html">Getting started</a></li></ul><ul><li><a href="intro-installation.html">Installation</a></li></ul><ul><li><a href="intro-sample.html">Sample project</a></li></ul><ul><li><a href="intro-use.html">Use cases</a></li></ul><ul><li><a href="intro-troubleshooting.html">Troubleshooting</a></li></ul></ul><ul><li><a href="definition.html">Definition</a></li><ul><li><a href="definition-library.html">Library definition</a></li><ul><li><a href="definition-library-functions.html">Functions</a></li></ul><ul><li><a href="definition-library-constants.html">Constants</a></li></ul><ul><li><a href="definition-link.html">Linking subdefinitions</a></li></ul></ul><ul><li><a href="definition-sub.html">Sublibraries</a></li></ul><ul><li><a href="definition-type.html">Library datatype definition</a></li><ul><li><a href="definition-type-nested.html">Nested data</a></li></ul></ul><ul><li><a href="definition-enum.html">Enumerations</a></li></ul><ul><li><a href="definition-metadata.html">Metadata</a></li></ul><ul><li><a href="definition-ffi.html">FFI types</a></li><ul><li><a href="definition-ffi-size.html">Size types</a></li></ul><ul><li><a href="definition-ffi-callbacks.html">Callbacks</a></li></ul></ul></ul><ul><li><a href="configuration.html">Configuration</a></li><ul><li><a href="configuration-general.html">General configuration</a></li></ul><ul><li><a href="configuration-library.html">Library configuration</a></li></ul></ul><ul><li><a href="target.html">Target details</a></li><ul><li><a href="target-hxcpp.html">C++</a></li></ul><ul><li><a href="target-eval.html">Eval</a></li></ul><ul><li><a href="target-hashlink.html">HashLink</a></li></ul><ul><li><a href="target-lua.html">Lua</a></li></ul></ul><ul><li><a href="library.html">Native library development</a></li></ul><ul><li><a href="ammer.html">Implementation details</a></li><ul><li><a href="ammer-testing.html">Testing</a></li></ul><ul><li><a href="ammer-stages.html">Compilation stages</a></li></ul></ul></nav>
	<main><h2>Library datatype definition</h2><p>To define a library datatype, extend <code>ammer.Pointer&lt;..., ...&gt;</code> with a regular Haxe class. The first type parameter for <code>ammer.Pointer</code> should be a string identifying the native C type name (without the <code>*</code>). The second type parameter should be the <code>ammer</code> library this type belongs to.</p>
<div class="example">

<h3>Example: library datatype definition</h3><pre><code class="language-haxe">class FoobarType extends ammer.Pointer&lt;&quot;foobar_t&quot;, Foobar&gt; {
  // ...
}</code></pre>
<p>In this example, <code>FoobarType</code> is a library datatype for the <code>Foobar</code> library. The first type parameter is <code>foobar_t</code>, which means functions which work with this datatype would accept <code>foobar_t *</code>.</p>
</div>

<p>Sometimes it is useful to associate some functions of a library with the datatype rather than the library itself, then in Haxe code use them as non-static instance methods rather than static methods. Library datatype functions are defined just like <a href="definition-library-functions.html" title="Functions">library functions</a>, with two differences:</p>
<ul>
<li>they are declared as <code>public function</code></li>
<li>one of their arguments must be of the special <code>ammer.ffi.This</code> type</li>
</ul>
<p>When calling instance functions of a library datatype, the <code>This</code> argument is omitted, as it is automatically filled in with the used instance.</p>
<div class="example">

<h3>Example: library datatype function</h3><pre><code class="language-haxe">class FoobarType extends ammer.Pointer&lt;&quot;foobar_t&quot;, Foobar&gt; {
  public function doFoobarAction(_:ammer.ffi.This, a:Int, b:Int):Int;
}</code></pre>
<p>In this example, <code>doFoobarAction</code> is a datatype function. In Haxe code, it could be used like this:</p>
<pre><code class="language-haxe">var x:FoobarType = ...;
x.doFoobarAction(3, 4);</code></pre>
<p>Note that the first argument for <code>doFoobarAction</code> is not specified – <code>x</code> is used automatically.</p>
</div>

<p>The rules for identifying the native function names are the same as for library functions. Unlike libraries, library datatypes cannot contain <code>static</code> functions or constants.</p>
<h3 id="variables">Variables</h3><p>Library datatypes can also have variables. Variables must be declared using <code>public var</code> fields.</p>
<div class="example">

<h3>Example: library datatype variables</h3><pre><code class="language-haxe">class FoobarType extends ammer.Pointer&lt;&quot;foobar_t&quot;, Foobar&gt; {
  public var bar:Int;
}</code></pre>
<p>In this example, <code>FoobarType</code> is a library datatype for the <code>Foobar</code> library. It has a <code>bar</code> variable that can be read or written:</p>
<pre><code class="language-haxe">var x:FoobarType = ...;
x.bar = 3;
var y = x.bar;</code></pre>
</div>

<p>Variables map to pointer accesses in C code, so a <code>bar</code> variable is read as <code>(someStruct)-&gt;bar</code> and written as <code>(someStruct)-&gt;bar = value</code>. Note that any read or write variable access has a runtime cost of a function call.</p>
<p>The rules for identifying the native variable names are the same as for functions.</p>
<h3 id="struct-types">Struct types</h3><p><a href="definition-metadata.html#ammer.struct" title="Metadata"><code>@:ammer.struct</code></a> can be used to specify that the pointer is a pointer to a struct known at compile time (not an incomplete or <code>extern</code> struct). Doing this adds the static method <code>alloc</code> and the instance method <code>free</code> to the type.</p>
<div class="example">

<h3>Example: library datatype struct</h3><pre><code class="language-haxe">@:ammer.struct
class FoobarType extends ammer.Pointer&lt;&quot;foobar_t&quot;, Foobar&gt; {
  public var bar:Int;
}</code></pre>
<p>In this example, <code>FoobarType</code> is a library datatype for the <code>Foobar</code> library. It is declared a struct, which means that the <code>alloc</code> and <code>free</code> methods are implicitly added. Supposing there is a <code>Foobar.takeStruct(x:FoobarType)</code> method:</p>
<pre><code class="language-haxe">var x = FoobarType.alloc();
x.bar = 42;
Foobar.takeStruct(x);
x.free();</code></pre>
</div>

<p>Note that incorrect use of <code>alloc</code> and <code>free</code> may lead to memory leaks or segmentation faults at runtime. A struct that is <code>alloc</code>&#39;ed once must be <code>free</code>&#39;d manually at a later point, because the garbage collector cannot do it automatically. Once a struct is <code>free</code>&#39;d, its fields should not be accessed, nor should the Haxe object referencing the struct be passed into any library functions, because the pointer becomes invalid.</p>
<h3>Linking</h3><p>Library datatypes might need to be linked with the parent library using <code>@:ammer.sub(...)</code>. See <a href="definition-link.html" title="Linking subdefinitions">linking subdefinitions</a>.</p>
<h3>Metadata applicable to library datatypes</h3><ul>
<li><a href="definition-metadata.html#ammer.nativePrefix" title="Metadata"><code>@:ammer.nativePrefix</code></a></li>
<li><a href="definition-metadata.html#ammer.struct" title="Metadata"><code>@:ammer.struct</code></a></li>
</ul>
<h3>Planned features</h3><p>See <a href="https://github.com/Aurel300/ammer/issues/3" target="_blank">related issue</a>.</p>
<ul>
<li>Pass-by-value semantics.</li>
<li>Optimised variable access without a function call.</li>
</ul>
</main>
	<a id="page-prev" href="definition-sub.html">« Previous: Sublibraries</a>
	<a id="page-next" href="definition-type-nested.html">Next: Nested data »</a>
	<footer>
		<a href="https://github.com/Aurel300/ammer/blob/gh-pages-src/content/02-definition.md">Contribute to this page</a>
		| <a href="https://github.com/Aurel300/ammer/" target="_blank"><code>ammer</code> on GitHub</a>
		| &copy; 2019-2021 Aurel Bílý
	</footer>
</body></html>