<!DOCTYPE html><html><head>
	<title>Nested data – ammer manual</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="css/style.css" media="all">
</head><body>
	<header><a href="index.html"><h1>ammer</h1></a></header>
	<nav id="menu"><ul><li><a href="index.html">Introduction</a></li><ul><li><a href="intro-start.html">Getting started</a></li></ul><ul><li><a href="intro-installation.html">Installation</a></li></ul><ul><li><a href="intro-sample.html">Sample project</a></li></ul><ul><li><a href="intro-use.html">Use cases</a></li></ul><ul><li><a href="intro-troubleshooting.html">Troubleshooting</a></li></ul></ul><ul><li><a href="definition.html">Definition</a></li><ul><li><a href="definition-library.html">Library definition</a></li><ul><li><a href="definition-library-functions.html">Functions</a></li></ul><ul><li><a href="definition-library-constants.html">Constants</a></li></ul><ul><li><a href="definition-link.html">Linking subdefinitions</a></li></ul></ul><ul><li><a href="definition-sub.html">Sublibraries</a></li></ul><ul><li><a href="definition-type.html">Library datatype definition</a></li><ul><li><a href="definition-type-nested.html">Nested data</a></li></ul></ul><ul><li><a href="definition-enum.html">Enumerations</a></li></ul><ul><li><a href="definition-metadata.html">Metadata</a></li></ul><ul><li><a href="definition-ffi.html">FFI types</a></li><ul><li><a href="definition-ffi-size.html">Size types</a></li></ul><ul><li><a href="definition-ffi-callbacks.html">Callbacks</a></li></ul></ul></ul><ul><li><a href="configuration.html">Configuration</a></li><ul><li><a href="configuration-general.html">General configuration</a></li></ul><ul><li><a href="configuration-library.html">Library configuration</a></li></ul></ul><ul><li><a href="target.html">Target details</a></li><ul><li><a href="target-hxcpp.html">C++</a></li></ul><ul><li><a href="target-eval.html">Eval</a></li></ul><ul><li><a href="target-hashlink.html">HashLink</a></li></ul><ul><li><a href="target-lua.html">Lua</a></li></ul></ul><ul><li><a href="library.html">Native library development</a></li></ul><ul><li><a href="ammer.html">Implementation details</a></li><ul><li><a href="ammer-testing.html">Testing</a></li></ul><ul><li><a href="ammer-stages.html">Compilation stages</a></li></ul></ul></nav>
	<main><h2>Nested data</h2><p>Instances of <a href="definition-type.html" title="Library datatype definition">library datatypes</a> in <code>ammer</code> refer to pointers to the actual data, which is allocated on the heap. This is true even if the instance is contained in a field that is already a part of a struct.</p>
<div class="example">

<h3>Example: struct referring to struct by pointer</h3><pre><code class="language-haxe">class FoobarA extends ammer.Pointer&lt;&quot;foobar_a_t&quot;, Foobar&gt; {
  public var val:Int;
}

class FoobarB extends ammer.Pointer&lt;&quot;foobar_b_t&quot;, Foobar&gt; {
  public var bar:FoobarA;
}</code></pre>
<p>In this example, <code>FoobarA</code> and <code>FoobarB</code> are library datatype for the <code>Foobar</code> library. <code>FoobarB</code> has a field <code>bar</code>, which refers by pointer to an instance of <code>FoobarA</code>. The example might correspond to the following C structs:</p>
<pre><code class="language-c">typedef struct {
  int val;
} foobar_a_t;

typedef struct {
  foobar_a_t *bar;
} foobar_b_t;</code></pre>
<p>Note the <code>*</code> on <code>bar</code>.</p>
</div>

<p>If a field is instead meant to represent the struct itself, rather than a pointer to it, <code>ammer.ffi.Nested&lt;...&gt;</code> can be used.</p>
<div class="example">

<h3>Example: struct referring to struct by value</h3><pre><code class="language-haxe">class FoobarA extends ammer.Pointer&lt;&quot;foobar_a_t&quot;, Foobar&gt; {
  public var val:Int;
}

class FoobarB extends ammer.Pointer&lt;&quot;foobar_b_t&quot;, Foobar&gt; {
  public var bar:ammer.ffi.Nested&lt;FoobarA&gt;;
}</code></pre>
<p>In this example, <code>FoobarB</code> contains an instance of <code>FoobarA</code>. The example might correspond to the following C structs:</p>
<pre><code class="language-c">typedef struct {
  int val;
} foobar_a_t;

typedef struct {
  foobar_a_t bar;
} foobar_b_t;</code></pre>
<p>Note that <code>foobar_a_t</code> is embedded directly into <code>foobar_b_t</code>.</p>
</div>

<p><code>ammer.ffi.Nested&lt;...&gt;</code> can also be used to model the fields of a <code>union</code> (and C-like ADTs).</p>
<div class="example">

<h3>Example: unions and ADTs</h3><pre><code class="language-haxe">class FoobarParent extends ammer.Pointer&lt;&quot;foobar_parent_t&quot;, Foobar&gt; {
  public var isTypeA:Bool;
  public var aData:ammer.ffi.Nested&lt;FoobarA&gt;;
  public var bData:ammer.ffi.Nested&lt;FoobarB&gt;;
}

class FoobarA extends ammer.Pointer&lt;&quot;foobar_a_t&quot;, Foobar&gt; {
  public var x:Int;
  public var y:Int;
}

class FoobarB extends ammer.Pointer&lt;&quot;foobar_b_t&quot;, Foobar&gt; {
  public var f:Float;
}</code></pre>
<p>In this example, <code>FoobarParent</code> &quot;contains&quot; both data for a <code>FoobarA</code> instance and a <code>FoobarB</code> instance. Assuming a C definition as shown below, this could form a simple ADT.</p>
<pre><code class="language-c">typedef struct {
  int x;
  int y;
} foobar_a_t;

typedef struct {
  double f;
} foobar_b_t;

typedef struct {
  bool isTypeA;
  union {
    foobar_a_t aData;
    foobar_b_t bData;
  };
}</code></pre>
<p>In Haxe, one could use the ADT with a <code>switch</code> like so:</p>
<pre><code class="language-haxe">var x:FoobarParent = ...;
switch [x.isTypeA, x] {
  case [true, _.aData =&gt; data]:
    trace(&quot;FoobarA&quot;, data.x, data.y);
  case [false, _.bData =&gt; data]:
    trace(&quot;FoobarB&quot;, data.f);
}</code></pre>
</div>

</main>
	<a id="page-prev" href="definition-type.html">« Previous: Library datatype definition</a>
	<a id="page-next" href="definition-enum.html">Next: Enumerations »</a>
	<footer>
		<a href="https://github.com/Aurel300/ammer/blob/gh-pages-src/content/02-definition.md">Contribute to this page</a>
		| <a href="https://github.com/Aurel300/ammer/" target="_blank"><code>ammer</code> on GitHub</a>
		| &copy; 2019-2021 Aurel Bílý
	</footer>
</body></html>