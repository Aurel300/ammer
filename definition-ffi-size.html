<!DOCTYPE html><html><head>
	<title>Size types – ammer manual</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="css/style.css" media="all">
</head><body>
	<header><a href="index.html"><h1>ammer</h1></a></header>
	<nav id="menu"><ul><li><a href="index.html">Introduction</a></li><ul><li><a href="intro-start.html">Getting started</a></li></ul><ul><li><a href="intro-installation.html">Installation</a></li></ul><ul><li><a href="intro-sample.html">Sample project</a></li></ul><ul><li><a href="intro-use.html">Use cases</a></li></ul><ul><li><a href="intro-troubleshooting.html">Troubleshooting</a></li></ul></ul><ul><li><a href="definition.html">Definition</a></li><ul><li><a href="definition-library.html">Library definition</a></li><ul><li><a href="definition-library-functions.html">Functions</a></li></ul><ul><li><a href="definition-library-constants.html">Constants</a></li></ul></ul><ul><li><a href="definition-type.html">Library datatype definition</a></li></ul><ul><li><a href="definition-metadata.html">Metadata</a></li></ul><ul><li><a href="definition-ffi.html">FFI types</a></li><ul><li><a href="definition-ffi-size.html">Size types</a></li></ul></ul></ul><ul><li><a href="configuration.html">Configuration</a></li><ul><li><a href="configuration-general.html">General configuration</a></li></ul><ul><li><a href="configuration-library.html">Library configuration</a></li></ul></ul><ul><li><a href="target.html">Target details</a></li><ul><li><a href="target-hxcpp.html">C++</a></li></ul><ul><li><a href="target-eval.html">Eval</a></li></ul><ul><li><a href="target-hashlink.html">HashLink</a></li></ul><ul><li><a href="target-lua.html">Lua</a></li></ul></ul><ul><li><a href="library.html">Native library development</a></li></ul><ul><li><a href="ammer.html">Implementation details</a></li><ul><li><a href="ammer-testing.html">Testing</a></li></ul><ul><li><a href="ammer-stages.html">Compilation stages</a></li></ul></ul></nav>
	<main><h2>Size types</h2><h3><code>String</code></h3><p>Since Haxe 4, <code>String</code>s consist of Unicode codepoints. Internally, different targets represent strings differently, but in <code>ammer</code> library definitions, strings are always understood as valid UTF-8 sequences.</p>
<p>Although the null byte is a valid Unicode codepoint, some Haxe targets use it to terminate strings, and C libraries in general use it as an end-of-string marker. This is why a single <code>char *</code> argument is sufficient to pass a string to native libraries; the null byte is used to detect the end of the string. To pass UTF-8 data which includes null bytes, <code>haxe.io.Bytes</code> has to be used instead.</p>
<h3><code>Bytes</code></h3><p><code>haxe.io.Bytes</code> values represent arbitrary binary data. In terms of C types, these can be thought of as a pointer (<code>unsigned char *</code>) and a corresponding length (<code>size_t</code> or <code>int</code>). When a native library expects arbitrary binary data, it often needs to know both of these values, passed as separate arguments. On the Haxe side, however, a single argument is sufficient. To facilitate this difference, the length argument given to the native library is marked with the type <code>ammer.ffi.SizeOf</code> with the name of the corresponding argument as a type parameter. In Haxe code, the marked argument is not present, as it is always based on the length of the <code>Bytes</code> instance.</p>
<pre><code class="language-haxe">class Foobar extends ammer.Library&lt;&quot;foobar&quot;&gt; {
  public static function validate(buf:haxe.io.Bytes, len:ammer.ffi.SizeOf&lt;&quot;buf&quot;&gt;):Bool;
}

class Main {
  public static function main():Void {
    // note the `len` argument is not given:
    trace(Foobar.validate(haxe.io.Bytes.ofHex(&quot;CAFFE00CAFFE&quot;)));
  }
}</code></pre>
<p>If the size of a <code>Bytes</code> object is not passed along to the library at all, the argument type should be wrapped in <code>ammer.ffi.NoSize</code>:</p>
<pre><code class="language-haxe">public static function takeBuffer(buf:ammer.ffi.NoSize&lt;haxe.io.Bytes&gt;):Void;</code></pre>
<p>When a C API returns a binary buffer, one of the arguments may be a pointer to which the size of the buffer will be written. This can be expressed with the type <code>ammer.ffi.SizeOfReturn</code>. Once again, in Haxe code, this argument will not be present.</p>
<pre><code class="language-haxe">class Foobar extends ammer.Library&lt;&quot;foobar&quot;&gt; {
  public static function makeData(len:ammer.ffi.SizeOfReturn):haxe.io.Bytes;
}

class Main {
  public static function main():Void {
    // note the `len` argument is not given:
    trace(Foobar.makeData());
  }
}</code></pre>
<p>When a native library returns a binary buffer that is the same size as one of the input arguments, the return type can be wrapped with <code>ammer.ffi.SameSizeAs</code>:</p>
<pre><code class="language-haxe">public static function reverseBuffer(buf:haxe.io.Bytes, len:ammer.ffi.SizeOf&lt;&quot;buf&quot;&gt;):ammer.ffi.SameSizeAs&lt;haxe.io.Bytes, &quot;buf&quot;&gt;;</code></pre>
</main>
	<a id="page-prev" href="definition-ffi.html">« Previous: FFI types</a>
	<a id="page-next" href="configuration.html">Next: Configuration »</a>
	<footer>
		<a href="https://github.com/Aurel300/ammer/blob/master/manual/content/02-definition.md">Contribute to this page</a>
		| <a href="https://github.com/Aurel300/ammer/" target="_blank"><code>ammer</code> on GitHub</a>
		| &copy; 2019-2020 Aurel Bílý
	</footer>
</body></html>