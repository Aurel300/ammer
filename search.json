[["intro-overview",null,"Overview",null,"Overview\nThis document aims to be the definitive, exhaustive documentation for the ammer project and its associated repositories ( ammer-core, HaxeAmmer/amlib-*). Knowledge of the Haxe language is assumed (see the Haxe manual ), as well as some knowledge of the C language.\nThe sections are organised as follows:\nIntroduction — General overview. Overview\nTerminology\nWhy ammer?\nInstallation\nGetting started\n\nDefinition — Guide-level explanation of writing library definitions using ammer. Library definition\nDatatypes\n\nConfiguration — Guide-level explanation of library configuration. Providing flags\nProject-wide configuration\nLibrary configuration\n\nTarget details — Target-specific information. Feature parity\nC++\nC#\nEval\nHashLink (both JIT and HL/C)\nJava (both Java and JVM)\nLua\nNeko\nNode.js\nPython\n\nReference — Full reference of the available APIs, metadata, and ammer types. FFI types\nammer.def.* types\nammer.Lib\nList of configuration flags\nList of annotations\n\namlib — Writing and publishing ammer libraries. Conventions\nCI\nBaking\n\nAdvanced topics — More advanced considerations when writing library definitions. Type cycles\nGarbage collection\nString encoding\nStatic and dynamic linking\nPackaging and distribution\nPerformance\n\nammer-core — About the underlying framework. Interface\nImplementing new platforms\n\n"],["intro-terminology",null,"Terminology",null,"Terminology\nIn the context of Haxe and its use with ammer, terms such as \"native\" or \"library\" can be ambiguous. Throughout this document, the terms will have the following meaning:\nnative library — Native libraries is typically distributed as .dll (on Windows), .dylib (on macOS), or .so (on Linux). Usually such libraries are written in a system language such as C, and compiled into machine code \"native\" to a particular architecture or operating system. Examples: libPNG , SDL 2 , libuv .\n\nHaxe library — Haxe libraries are packages containing Haxe code, distributed via haxelib , Github, or other means. Examples: HaxeUI , OpenFL , pecan .\n\nammer library — A subset of the previous, ammer libraries are Haxe libraries made using ammer.\nlibrary — One the above. Should only be used when the context makes it clear which one is meant !\nammer library definition — To create an ammer library, a \"definition\" is needed, consisting of specially annotated Haxe classes and methods, as described in the Definition section .\nextern — Haxe allows marking classes and other types as externs (see the Externs section in the Haxe manual), which allows non-Haxe code (such as functions written in Javascript) to be used safely from within Haxe code.\ntarget — The Haxe compiler compiles Haxe code into one of its various targets, such as C#, Javascript, or HashLink. However, this is not precise enough: it is also important to know how the resulting code is compiled and how it will be executed. In this document, \"target\" refers to such a more precise combination of target language + runtime platform. Examples: Javascript on Node.js, HashLink in HL/C mode.\n\nFFI — Foreign Function Interface. On targets with an interpreter (such as Node.js/V8) or a virtual machine (such as the JVM) this generally refers to a mechanism that allows code to interact with native libraries.\nWith the above in mind, ammer is a Haxe library which is used to create ammer libraries. Typically, their function is to make a native library usable from Haxe. The author of an ammer library creates a library definition corresponding to the API of a native library. Although ammer uses externs under the hood (on some targets), this is not directly visible; in other words, ammer library definitions aim to be a more general concept than externs.\n"],["intro-use",null,"Why ammer?",null,"Why ammer?\nUnlike Haxe externs and manually written glue code, ammer definitions provide a unified interface: the same definition can be used for C++, for HashLink, for Node.js, etc. Additionally, writing externs and glue code is extremely error-prone and tedious, and requires detailed knowledge of the FFI mechanism used by each platform. ammer aims to hide this technical complexity, allowing library authors to focus purely on the API of the library they are defining. Any necessary externs and glue code is generated automatically. Any issues that are identified in this process can be fixed once, to the benefit of all ammer libraries.\nammer can be seen as an extension of the \"Haxe promise\": write code once and run it anywhere. With ammer this is true also for code that interacts with native libraries, which is crucial for real-world codebases.\n"],["intro-installation",null,"Installation",null,"Installation\nammer can be installed as a git library:\n# using SSH\n$ haxelib git ammer git@github.com:Aurel300/ammer.git\n# or using HTTPS\n$ haxelib git ammer https://github.com/Aurel300/ammer.git\nAlternatively, the Github repository can be cloned manually and ammer can be installed as a dev library:\n$ git clone git@github.com:Aurel300/ammer.git\n$ cd ammer\n$ haxelib dev ammer .\nammer requires a C compiler toolchain to be installed. Any GCC-compatible compiler should work, as well as MSVC. Each target may have additional dependencies — see target details .\n"],["intro-start",null,"Getting started",null,"Getting started\nTo use an existing native library, all that is required is to write a library definition :\nclass Foobar extends ammer.def.Library<\"foobar\"> {\n public static function repeat(word:String, count:Int):String;\n}\nThe types used in the arguments must be among the supported FFI types . Libraries can define functions , variables , and datatypes . The functions can then be called like regular Haxe functions:\nclass Main {\n public static function main():Void {\n  trace(Foobar.repeat(\"hello\", 3));\n }\n}\nDuring compilation, the ammer haxelib must be used. Library-specific configuration can be added either using metadata or define flags. The define flags must include at least a build path (used for intermediate files) and an output path (where the ammer-generated dynamic libraries will be placed):\n--library ammer\n-D ammer.buildPath=build\n-D ammer.outputPath=bin\n--main Main\n--hl bin/out.hl\nA variety of configuration flags can be provided; see configuration for more details.\n"],["definition",null,"Definition",null,"Definition\nAn ammer library is a set of library definitions and library datatype definitions. Since Haxe organises code into modules and classes, both libraries and library datatypes are defined using Haxe classes. This section provides a guide-level explanation of the various parts of a library definition, with examples. Further detail can be found in later sections.\nLibraries\nThe APIs of native libraries consist of a set of exported functions. An ammer library definition should list these functions and adapt their signatures to Haxe types. Library definitions can also expose constants.\nRead on: Library definition\nDatatypes\nIn addition to functions, libraries often define their own datatypes which group together data in a meaningful way. In C, these correspond to pointers to struct types, opaque pointers, enum types, or union types.\nRead on: Library datatype definition\n"],["definition-library",null,"Library definition",null,"Library definition\nTo define a library, extend ammer.def.Library<...> with a Haxe class. The type parameter for ammer.def.Library should be a string identifier for the native library. This identifier is used in the library configuration , so it must only consist of letters and underscores.\nExample: library definition\npackage foo;\n\nclass Foobar extends ammer.def.Library<\"foobar\"> {\n // ...\n}\nIn this example, foo.Foobar is an ammer library definition for the native library called foobar. A library definition typically includes metadata which configures properties such as the include path, the language of the native library, headers to use, etc. See configuration for more details.\nThe fields of a library definition consist of functions and variables . Libraries can also be split up into several classes, see sublibraries .\nMetadata applicable to library definitions\nMetadata can be attached to the library definition class. This allows for configuration of the library compilation, its source language, header files, and more. See the full metadata descriptions for more information:\n@:ammer.lib.define\n@:ammer.lib.framework\n@:ammer.lib.frameworks\n@:ammer.lib.includePath\n@:ammer.lib.includePaths\n@:ammer.lib.language\n@:ammer.lib.libraryPath\n@:ammer.lib.libraryPaths\n@:ammer.lib.linkName\n@:ammer.lib.linkNames\n@:ammer.lib.headers.include\n@:ammer.lib.headers.import\n@:ammer.lib.headers.includeLocal\n@:ammer.lib.headers.importLocal\n@:ammer.lib.headers.includeGlobal\n@:ammer.lib.headers.importGlobal\n@:ammer.nativePrefix\n@:ammer.sub\n"],["definition-library-functions",null,"Functions",null,"Functions\nFunctions can be declared in library definitions using public static fuction fields with no function body (similar to Haxe externs).\nExample: function in library definition\nclass Foobar extends ammer.def.Library<\"foobar\"> {\n public static function hello(a:Int, b:String):Float;\n}\nIn this example, hello is a function in the Foobar library. The function maps to the native function double hello(int a, char *b) (in C types).\nAll return types and argument types must be written explicitly, since Haxe type inference is not compatible with native libraries. Only a subset of Haxe types can be used. See FFI types .\n"],["definition-library-functions","macros","Functions","Macros","Macros\nThe same public static function syntax can be used to declare C preprocessor macro calls, but the additional metadata @:ammer.macroCall should be applied. Macros which require unusual C syntax may cause a compilation failure: for arbitrary C code expressions, see the next section .\n"],["definition-library-functions","custom-c","Functions","Customising the C code","Customising the C code\nFor every method declared in an ammer definition, there is glue code generated which has the following general shape:\ntarget_return_type func(args...) {\n native_args = ... // \"pre\": decode arguments from target-specific representation to C\n ... // \"prereturn\"\n c_return_type _return =\n  native_call(native_args...); // \"return\"\n ... // \"post\": encode returned value to a target-specific representation, cleanup, return\n}\nA large part of the function, including its exact signature, depends on the concrete target. However, ammer ensures that the initial part of the function code gets the local variables to the same state on any platform: the local variables _arg0, ..., _argN are of the C types corresponding to the declared argument types.\nIf there is additional code that should be called before the actual native call happens, it can be inserted at the point marked \"prereturn\" above. This is accomplished with the @:ammer.c.prereturn metadata.\nIf the native call itself should be replaced with a different C expression, this can be accomplished with the @:ammer.c.return metadata. The substring %CODE% will be replaced in the provided code with the original call expression.\n"],["definition-library-functions","pure-haxe","Functions","Pure Haxe functions","Pure Haxe functions\nThe @:ammer.haxe metadata can be used to define methods on libraries which are implemented purely in Haxe and have no native counterpart. When this metadata is attached to a method (and only then), it may have a body.\nMetadata applicable to functions\nMetadata can be used to inject additional C code into the wrapper code, mark functions as macro calls, or provide the native name for a function. See the full metadata descriptions for more information:\n@:ammer.haxe\n@:ammer.macroCall\n@:ammer.native\n@:ammer.c.macroCall\n@:ammer.c.prereturn\n@:ammer.c.return\n@:ammer.ret.derive\nThe following metadata can be attached to function arguments:\n@:ammer.skip\n@:ammer.derive\n@:ammer.c.cast\n"],["definition-library-variables",null,"Variables",null,"Variables\nVariables can be declared in library definitions using public static var fields.\nExample: variable in library definition\nclass Foobar extends ammer.def.Library<\"foobar\"> {\n public static var bar:Int;\n}\nIn this example, bar is an integer variable in the Foobar library.\nAs for function signatures, variable types are restricted to a subset of Haxe types. See FFI types .\n"],["definition-library-variables","constants","Variables","Constants","Constants\nIf a value from a native library is available immediately, such as constants or macro definitions, it can be declared as a constant in the ammer definition using a public static final field.\nExample: constant in library definition\nclass Foobar extends ammer.def.Library<\"foobar\"> {\n @:ammer.native(\"HELLO_WORLD\")\n public static final helloWorld:String;\n}\nIn this example, helloWorld is a string constant for the Foobar ammer library definition. The headers of the foobar native library must ensure that HELLO_WORLD is a valid C expression, for example with #define HELLO_WORLD \"hello world\".\n@:ammer.native can be used to specify the C expression which will be used to determine the value of a constant. There is no restriction to what the expression can be: it may be a literal, a constant, the result of a library call, and so forth. However, all constant values are initialised at the same time, typically before Haxe main is reached, so the C expression should not be a mutable value, because it will not be updated.\nMetadata applicable to variables and constants\n@:ammer.native\n"],["definition-sub",null,"Sublibraries",null,"Sublibraries\nFor better code organisation, it is possible to split a library definition into multiple classes. If the separate class consists of static functions and not \"instance\" methods (in which case a library datatype definition might be more appropriate), it can be defined as a sublibrary.\nTo define a sublibrary, extend ammer.def.Sublibrary<...> with a Haxe class. The type parameter for ammer.def.Sublibrary should be the ammer library this class belongs to.\nExample: sublibrary definition\n@:ammer.sub((_ : FoobarSub))\nclass Foobar extends ammer.def.Library<\"foobar\"> {}\n\nclass FoobarSub extends ammer.def.Sublibrary<Foobar> {\n // ...\n}\nIn this example, FoobarSub is a sublibrary belonging to Foobar.\nApart from forming a separate Haxe class, sublibraries behave identically to libraries .\nLinking\nSublibraries should be linked with the parent library using the @:ammer.sub(...) metadata to avoid compilation errors. See linking subdefinitions .\nMetadata applicable to sublibraries\n@:ammer.nativePrefix\n@:ammer.sub\n"],["definition-type",null,"Datatypes",null,"Datatypes\nLibraries often group data into complex types such as structs. To make use of these in Haxe code and in ammer library definitions, they can be defined as Haxe types.\nOpaque types\nOpaque types are types whose fields and layout are only known to the library that defines them. Any interaction with such types happens through methods defined by the library.\nRead on: Opaque types\nStructs\nStructs are types which contain fields, which can be read from or written to.\nRead on: Structs\nEnums\nEnums are sets of named values of the same type.\nRead on: Enums\nHaxe types\nNative libraries can store pointers to instances of Haxe types.\nRead on: Haxe types\nCallbacks\nCallbacks allow Haxe code to be called by the native library.\nRead on: Callbacks\n"],["definition-type-opaque",null,"Opaque types",null,"Opaque types\nWhen a native library uses a type in its API without revealing the actual fields and layout of that type (as is the case with structs ), the type can be called opaque. Such values cannot be allocated or freed, and can only be used meaningfully by passing them to the methods of the native library that defined them in the first place.\nTo define an opaque type, extend ammer.def.Opaque<...> with a Haxe class. The first type parameter for ammer.def.Opaque should be a string identifying the native C type name. The second type parameter should be the ammer library this type belongs to.\nAlthough opaque type definitions cannot contain any variable fields, they may still contain instance methods .\nExample: opaque type definition\nclass FoobarOpaque extends ammer.def.Opaque<\"opaque_t\", Foobar> {\n // ...\n}\nIn this example, FoobarOpaque is an opaque type of the Foobar library. The C name for this type is opaque_t.\nLinking\nOpaque types should be linked with the parent library using the @:ammer.sub(...) metadata to avoid compilation errors. See linking subdefinitions .\nMetadata applicable to opaque types\n@:ammer.nativePrefix\nNot yet implemented: large opaque types\nCurrently, ammer assumes every opaque type is pointer-sized or smaller. This allows passing it between Haxe and native code without any allocations. Supporting opaque types that do not fit into a pointer is a planned feature.\n"],["definition-type-struct",null,"Structs",null,"Structs\nWhen a struct type is not opaque , its fields are known and can be read and written directly, without using a library method.\nTo define a struct type, extend ammer.def.Struct<..., ...> with a Haxe class. The first type parameter for ammer.def.Struct should be a string identifying the native C type name. The second type parameter should be the ammer library this type belongs to.\nStruct definitions can contain variable fields , as well as instance methods .\nExample: library datatype definition\nclass FoobarStruct extends ammer.def.Struct<\"struct foobar_s\", Foobar> {\n // ...\n}\nIn this example, FoobarStruct is a struct in the Foobar library. The C name for this struct is struct foobar_s. Values of FoobarStruct in Haxe represent instances of struct foobar_s* (a pointer to struct foobar_s).\n"],["definition-type-struct","pointer","Structs","Instances are pointers","Instances are pointers\nNote that on the Haxe side, any struct value will be represented as a pointer to a struct. This is because most ammer targets do not support arbitrarily large stack-allocated data. See passing structs directly for declaring APIs which do not use a pointer indirection.\n"],["definition-type-struct","variables","Structs","Variables","Variables\nStructs definitions can contain variables, declared as public var or var fields.\nExample: struct variables\nclass FoobarStruct extends ammer.def.Struct<\"struct foobar_s\", Foobar> {\n public var bar:Int;\n}\nIn this example FoobarStruct has a bar variable that can be read or written:\nvar x:FoobarStruct = #dummy expr/*...*/;\nx.bar = 3;\nvar y = x.bar;\nVariables map to pointer accesses in C code, so a bar variable is read as (someStruct)->bar and written as (someStruct)->bar = value. Note that any read or write variable access may have a runtime cost of a function call.\n"],["definition-type-struct","alloc","Structs","Allocation and deallocation","Allocation and deallocation\nTo make it possible to allocate and deallocate a struct, it must be marked with the @:ammer.alloc metadata. When annotated, several functions are made available:\nalloc — a static function which allocates an instance of the given struct type. Initial values for its fields can optionally be passed using an object syntax.\nfree — an instance method which deallocates the underlying allocation.\nnullPtr — a static function which returns a null pointer of the given struct type.\nThe name of the generated functions can be changed to avoid conflicts with other functions. @:ammer.alloc is simply a convenience shortcut to the combination @:ammer.gen.alloc(\"alloc\"), @:ammer.gen.free(\"free\"), @:ammer.gen.nullPtr(\"nullPtr\"), where the string arguments specify the name of each generated method.\nExample: allocating and deallocating a struct\nGiven a struct definition annotated with @:ammer.alloc:\n@:ammer.alloc\nclass FoobarStruct extends ammer.def.Struct<\"struct foobar_s\", Foobar> {\n public var some_field:Int;\n}\nIt can be allocated by calling alloc:\n// with fields zeroed out:\nvar x = FoobarStruct.alloc();\n// or with some initial values:\nvar x = FoobarStruct.alloc({\n some_field: 42,\n});\nIt can then be deallocated:\nx.free();\nAnd a null pointer can be obtained:\nvar x = FoobarStruct.nullPtr();\n"],["definition-type-struct","deref","Structs","Passing structs directly","Passing structs directly\nNative methods which take a struct directly, as opposed to a pointer to a struct, can be declared by using the special ammer.ffi.Deref<...> type. This dereferences the struct pointer just before the native method call.\nExample: using ammer.ffi.Deref\nclass Foobar {\n public static function take_struct_ptr(x:FoobarStruct):Void;\n public static function take_struct_val(x:ammer.ffi.Deref<FoobarStruct>):Void;\n}\nThis example demonstrates passing a struct using a pointer and passing it directly. The corresponding C signatures could look like this:\nvoid take_struct_ptr(struct foobar_s* x) { /*...*/ }\nvoid take_struct_val(struct foobar_s x) { /*...*/ }\nNote that on the Haxe call side, the two methods are called the same way: by passing an instance of the FoobarStruct type. The dereferencing, if any, happens transparently.\nvar x:FoobarStruct = #dummy expr/*...*/;\nFoobar.take_struct_ptr(x);\nFoobar.take_struct_val(x);\nA similar situation arises when a native library method returns a struct value. To obtain a pointer to the struct, a heap allocation must take place to store that struct. In ammer, return types can be wrapped with the special ammer.ffi.Alloc<...> type to achieve this.\nExample: using ammer.ffi.Alloc\nclass Foobar {\n public static function give_struct_ptr():FoobarStruct;\n public static function give_struct_val():ammer.ffi.Alloc<FoobarStruct>;\n}\nThis example demonstrates a native method returning a pointer to a struct and one returning a struct directly. The corresponding C signatures could look like this:\nstruct foobar_s* give_struct_ptr() { /*...*/ }\nstruct foobar_s give_struct_val() { /*...*/ }\nNote that on the Haxe call side, the two methods have the same return type: an instance of FoobarStruct. The allocation, if any, happens transparently.\nvar x:FoobarStruct = Foobar.give_struct_ptr();\nvar y:FoobarStruct = Foobar.give_struct_val();\nLinking\nStructs should be linked with the parent library using the @:ammer.sub(...) metadata to avoid compilation errors. See linking subdefinitions .\nMetadata applicable to structs\n@:ammer.alloc\n@:ammer.nativePrefix\n@:ammer.sub\n@:ammer.gen.alloc\n@:ammer.gen.free\n@:ammer.gen.nullPtr\n"],["definition-type-instance",null,"Instance methods",null,"Instance methods\nAlthough C does not have the concept of instance methods (unlike, for example, Java or C++), native libraries often define APIs which simulate such a feature by passing a pointer to a struct or opaque type as the first argument.\nIn ammer, it is possible to use such methods as instance methods rather than static methods, resulting in more readable client code. To achieve this, a function must be declared in an opaque type definition or a struct definition with two requirements:\nIt must be declared as a function (and not a static function); and\none of its arguments must be of the special ammer.ffi.This type.\nWhen calling instance methods declared this way, the This argument is omitted, as it is automatically filled in.\nExample: instance method\nclass FoobarStruct extends ammer.def.Struct<\"struct foobar_s\", Foobar> {\n public function do_something(_:ammer.ffi.This, a:Int):Int;\n}\nIn this example, do_something is an instance method. In Haxe code, it could be used like this:\nvar x:FoobarStruct = #dummy expr/*...*/;\nx.do_something(42);\nNote that the first argument for do_something is not specified – x is used automatically.\n"],["definition-type-enum",null,"Enums",null,"Enums\nEnums are sets of distinct, named values of the same type. In C, this may be an actual enum declaration , or even a set of defines. Importantly, the values of an enum should be known at compile time.\nTo define an enum type, add @:build(ammer.def.Enum.build(..., ..., ...)) to a Haxe enum abstract. The first argument parameter for ammer.def.Enum.build should be a string identifying the native C type name. The second argument should be an FFI type . The third argument should be the ammer library this type belongs to.\nEnums should only contain variable declarations, one for each enum variant.\nExample: enum definition\n@:build(ammer.def.Enum.build(\"int\", Int32, Foobar))\nenum abstract FoobarEnum(Int) from Int to Int {\n @:ammer.native(\"FOOBAR_VAL1\") var Val1;\n @:ammer.native(\"FOOBAR_VAL2\") var Val2;\n // ...\n}\nIn this example, FoobarEnum is an enum in the Foobar library. The C type underlying this enum is a regular int. There are two variants: Val1 and Val2, which have the integer values available in the constants FOOBAR_VAL1 and FOOBAR_VAL2 at compile time.\nCompilation\nIn order for Haxe to be able to use ammer enums like regular enum abstracts, the value of each variant must be known at compile time. ammer will automatically extract the appropriate values by invoking the C compiler.\nLinking\nEnums should be linked with the parent library using the @:ammer.sub(...) metadata to avoid compilation errors. See linking subdefinitions .\n"],["definition-type-haxe",null,"Haxe types",null,"Haxe types\nC libraries often contain struct fields or function arguments of type void*, such that client code using the library can provide a pointer to its own datatypes. In ammer, such void* values can stand for instances of a Haxe type, such as a Haxe class instance.\nGarbage collection\nAll Haxe targets are garbage collected, which means it is the runtime&#39;s responsibility to understand which instances are no longer needed and can be re-used to free memory. For Haxe programs which do not interact with native libraries, this is not a problem. However, as soon as a Haxe instance is passed to a native library, a problem may arise: the Haxe runtime could decide that the Haxe instance is no longer usable, so it could be freed, but a reference to it may still be obtainable via the native library.\nThe solution used in ammer is to wrap Haxe instances with a reference counter, such that the programmer can indicate when a Haxe instance is or is not in use. To pass Haxe types to native libraries, use the ammer.ffi.Haxe<...> type in ammer definitions. When calling such functions, instances of Haxe types must first be wrapped using the ammer.Lib.createHaxeRef function. The resulting value has a value field to obtain the underlying Haxe instance, as well as an incref and decref function to increment or decrement the reference counter respectively.\nThe initial reference count of a Haxe reference is 0.\nExample: function accepting a Haxe type\nclass MyHaxeType { /*...*/ }\n\nclass Foobar extends ammer.def.Library<\"foobar\"> {\n public static function hello(a:ammer.ffi.Haxe<MyHaxeType>):Void;\n}\nIn this example, MyHaxeType is a regular Haxe class. The hello function of the Foobar library accepts an instance of MyHaxeType.\nvar x:MyHaxeType = #dummy expr/*...*/;\nvar xr = ammer.Lib.createHaxeRef(xr);\nxr.incref();\nFoobar.hello(xr);\nxr.decref();\n"],["definition-type-callbacks",null,"Callbacks",null,"Callbacks\nCallbacks allow native libraries to call Haxe code, for example, to invoke a handler when an event happens. Callbacks in C generally belong to two categories:\nStatic callbacks — the native library stores a function pointer directly.\nCallbacks with context — the native library stores a function pointer, as well as an additional void* value which is passed back to the function.\nIn ammer, a callback is declared using the ammer.ffi.Callback<...> type, which has 5 type parameters:\nammer.ffi.Callback<\n CallbackType,\n FunctionType,\n CallTarget,\n CallArgs,\n Lib\n>\nThe type parameters should be filled in as follows:\nCallbackType — The function type as seen by the native library.\nFunctionType — The function type as seen by Haxe.\nCallTarget — An expression (wrapped in square brackets) to reach the void* value representing the callback context, or \"global\".\nCallArgs — An array of expressions representing the arguments to pass to the Haxe function.\nLib — The parent ammer library.\nIt may be convenient to typedef callback types when referring to them within ammer definitions.\nExample: declaring and using a callback type\nAssuming a C library with the following implementation:\n// Type alias for the function type.\n// It receives two integer arguments, in addition to the user-defined context.\nint32_t (* callback_type)(int32_t, int32_t, void*);\n\nstatic callback_type *stored_fptr = NULL;\nstatic void *stored_context = NULL;\n\nvoid store_callback(callback_type *fptr, void *call_context) {\n stored_fptr = fptr;\n stored_context = call_context;\n}\n\nint32_t invoke_callback(int32_t a, int32_t b) {\n return stored(a, b, stored_context);\n}\nThe callback type can be reflected in ammer as follows:\ntypedef CallbackType = ammer.ffi.Callback<\n (ammer.ffi.Int32, ammer.ffi.Int32, Haxe<(Int, Int)->Int>)->ammer.ffi.Int32,\n (Int, Int)->Int,\n [arg2],\n [arg0, arg1],\n Foobar\n>;\nNote that [arg2] refers to the third, void*-typed argument of callback_type, whereas [arg0, arg1] refer to the first two, int-typed arguments.\nThe ammer definition for the C library above may look like this:\nclass Foobar extends ammer.def.Library<\"foobar\"> {\n public static function store_callback(_:CallbackType, _:ammer.ffi.Haxe<(Int, Int)->Int>):Void;\n public static function invoke_callback(_:ammer.ffi.Int32, _:ammer.ffi.Int32):ammer.ffi.Int32;\n}\nFinally, an example of using the library to invoke the callback:\nvar func = (a:Int, b:Int) -> { return a + b; };\nvar funcRef = ammer.Lib.createHaxeRef(func);\nfuncRef.incref();\nFoobar.store_callback(funcRef);\n\n// ...\n\ntrace(Foobar.invoke_callback(1, 2)); // 3\nNote the use of createHaxeRef: func is an instance of a Haxe type, thus it must be wrapped with a reference counter as explained in the Haxe types section .\n"],["definition-link",null,"Linking subdefinitions",null,"Linking subdefinitions\nIn addition to libraries , ammer offers four kinds of \"subdefinitions\":\nSublibraries\nOpaque types\nStructs\nEnums\nEach declaration declares a link to the parent library (e.g. ... extends ammer.Sublibrary<ParentLibrary>). However, a corresponding backlink should also be declared on the parent library, using the @:ammer.sub metadata. Although this declaration is optional (for the time being), it is recommended to avoid certain compilation errors, especially if the subdefinitions are declared in separate files. See type cycles for a technical explanation.\nExample: linking a sublibrary\n// in file Foobar.hx\n@:ammer.sub((_ : FoobarSub))\nclass Foobar extends ammer.def.Library<\"foobar\"> {}\n\n// in file FoobarSub.hx\nclass FoobarSub extends ammer.def.Sublibrary<Foobar> {}\nIn this example, Foobar links to its sublibrary using the @:ammer.sub metadata. FoobarSub links to its parent library using the type parameter of ammer.def.Sublibrary.\n"],["configuration",null,"Configuration",null,"Configuration\nIn addition to library definitions consisting of annotated Haxe classes, an ammer library must be configured such that it can be compiled properly. This section provides a guide-level explanation of the different aspects of ammer configuration, with examples. Further detail can be found in later sections.\nProviding flags\nMost configuration flags can be set using metadata or using compile-time defines.\nRead on: Providing flags\nProject-wide configuration\nammer requires a few flags to be set for the project as a whole before compilation can proceed.\nRead on: Project-wide configuration\nLibrary configuration\nLibraries can be configured to include particular header files, to use certain paths as the include/library paths for the C compiler, to define C preprocessor values, and so forth.\nRead on: Library configuration\n"],["configuration-providing",null,"Providing flags",null,"Providing flags\nA \"configuration flag\" in this document refers to a string key, such as ammer.buildPath associated to a value of a given type, such as String. Most configuration flags can be set using two ways:\nEither by annotating a library definition with metadata; or\nby providing a compile-time define when invoking the Haxe compiler.\nFor configuration flags associated to a particular library (for example: \"which header files should be included when compiling this library\"), using metadata is the more natural option. The relevant metadata are written in the same file as the definition of the library itself, which means information is not spread across too many places. Nevertheless, defines can be used to override the library behaviour on a per-project basis.\nConfiguration flags which are not associated to any library can only be provided using defines.\nExample: providing flags\n@:ammer.lib.headers.include(\"png.h\")\nclass LibPng extends ammer.def.Library<\"png\"> {\n // ...\n}\nIn this example, the LibPng library is configured to include the png.h header file during compilation using metadata. Alternatively, the metadata can be omitted, and the flag provided using a compile-time define:\n-D ammer.lib.png.headers.include=png.h\nNote the naming convention: in the metadata case, the metadata is attached directly to the LibPng class, so providing the png identifier as part of the metadata name would be redundant. On the other hand, the compile-time define must specify which library it is referring to by using the png identifier as part of the define name.\n"],["configuration-project",null,"Project-wide configuration",null,"Project-wide configuration\nWhen building a project that uses an ammer library there are two flags which are required: the build and output paths . Other, optional flags, allow enabling the debug mode for ammer, setting target-specific options , or configuring the build system .\n"],["configuration-project","paths","Project-wide configuration","Paths","Paths\nThere are two paths that need to be configured before ammer can continue compilation.\nThe build path, configured using #lang-hxml -D ammer.buildPath, specifies a path used as an intermediate directory. During compilation, ammer creates C files containing the glue code required to use a native library with the currently selected Haxe target. These files, as well as the intermediate outputs of the C compiler, are all placed into the build path. The build path is created if it does not exist.\nThe output path, configured using #lang-hxml -D ammer.outputPath, specifies the path for the resulting ammer-built dynamic libraries, which are files with the extensions .dll, .so, .dylib, .hdll, or .ndll. These files must be distributed with the final executable for the library to function properly.\n"],["configuration-project","debug","Project-wide configuration","Debug mode","Debug mode\nFull debug logging for ammer can be enabled using #lang-hxml -D ammer.debug=all. During compilation, this will cause a lot of additional output that may be useful for ammer-debugging purposes.\n"],["configuration-project","target","Project-wide configuration","Target-specific configuration","Target-specific configuration\nThe configuration flags specific to each target are described in the target details section. These flags are prefixed with the target they apply to. For example, ammer.hl. is the prefix for all HashLink-specific configuration flags.\n"],["configuration-project","build","Project-wide configuration","Build system configuration","Build system configuration\n(TODO)\n"],["configuration-library",null,"Library configuration",null,"Library configuration\nConfiguration flags specific to a library are typically provided by annotating the library definition with metadata, although they can be overridden on a per-project basis using defines (see providing flags ).\n"],["configuration-library","includes","Library configuration","Includes","Includes\nThe API of C libraries, consisting of function signatures and types, is typically made available by including a header file.\nExample: including a header file\n@:ammer.lib.headers.include(\"png.h\")\nclass LibPng extends ammer.def.Library<\"png\"> {\n // ...\n}\nIn this example, the LibPng library is configured to include the png.h header file during compilation using metadata. This corresponds to the C code:\n#include \"png.h\"\nThere are different styles of includes, see @:ammer.lib.headers.includes.\n"],["configuration-library","link-names","Library configuration","Link names","Link names\nThe @:ammer.lib.linkName metadata configures the name(s) of the dynamic library that ammer should link against such that native functions are available. This corresponds to the GCC flag -l.\nExample: setting the link name\n@:ammer.lib.linkName(\"png\")\nclass LibPng extends ammer.def.Library<\"png\"> {\n // ...\n}\nIn this example, the LibPng library is configured to link against the png dynamic library. The C compiler will receive the argument -lpng.\nUnless configured otherwise, an ammer library uses its identifier as the link name. Some libraries (e.g. \"header-only\" libraries where the implementation is enabled with a preprocessor define ) have no dynamic library to link against: in this case, @:ammer.lib.linkNames([]) can be used to clear the list of link names.\nOn macOS, \"frameworks\" are packages of headers and dynamic libraries. The @:ammer.lib.framework metadata can be used to declare that an ammer library uses a particular framework.\n"],["configuration-library","defines","Library configuration","Defines","Defines\nC preprocessor defines can be enabled for a library using the @:ammer.lib.define metadata.\n"],["configuration-library","paths","Library configuration","Paths","Paths\nWhen resolving header includes and when linking, the compiler needs to know where to look. ammer libraries can be configured with include paths and library paths. These paths correspond to the GCC flags -I and -L, respectively.\nInclude paths can be configured using the @:ammer.lib.includePath metadata, library paths can be configured using the @:ammer.lib.libraryPath metadata.\nBoth include paths and library paths are set relative to the file they are declared in .\nExample: setting the include path\n@:ammer.lib.includePath(\"../../native\")\n@:ammer.lib.headers.include(\"png.h\")\nclass LibPng extends ammer.def.Library<\"png\"> {\n // ...\n}\nAssuming the directory hierarchy is as follows:\nnative/\n png.h\nhaxe/\n src/\n  LibPng.hx\nThe compiler will look for the png.h header file in the directory native.\n"],["configuration-library","language","Library configuration","Language","Language\nBy default, ammer generates glue code in the C language. For libraries requiring the use of another language, the language can be changed using the @:ammer.lib.language metadata. Currently supported languages are:\nC - C\nCpp - C++\nObjC - Objective-C\nObjCpp - Objective-C++\n"],["target",null,"Target details",null,"Target details\nammer aims to support all Haxe sys targets , including Javascript compiled with hxnodejs, but excluding PHP. \nFeature parity\nEach ammer target supports the same set of features, unless otherwise noted.\nRead on: Feature parity\nTarget-specific information\nThe rest of this chapter contains information on how each target should be used, its configuration flags, etc.\nRead on:\nC++\nC#\nEval\nHashLink (both JIT and HL/C)\nJava (both Java and JVM)\nLua\nNeko\nNode.js\nPython\n"],["target-feature-parity",null,"Feature parity",null,"Feature parity\n"],["target-feature-parity","shared-buffers","Feature parity","Shared buffers","Shared buffers\nSince each ammer target has a different runtime with different internal representations of core types such as haxe.io.Bytes, some targets do not support directly sharing memory between Haxe code and native code.\nIn the target summaries in the remaining sections, \"Shared buffers\" is one of the following:\nYes - haxe.io.Bytes can be passed directly (without copying) to the native library as a byte pointer and vice versa.\nFrom Haxe to native only - haxe.io.Bytes can be passed directly (without copying) to the native library as a byte pointer but a native byte pointer cannot be used as a haxe.io.Bytes value.\nNo - haxe.io.Bytes must always be copied to get a byte pointer.\n"],["target-feature-parity","shared-vectors","Feature parity","Shared vectors","Shared vectors\nIn the target summaries in the remaining sections, \"Shared vectors\" is one of the following:\nYes - haxe.ds.Vector can be passed directly (without copying) to the native library as a pointer and vice versa.\nFrom Haxe to native only - haxe.ds.Vector can be passed directly (without copying) to the native library as a pointer but a native pointer cannot be used as a haxe.ds.Vector value.\nNo - haxe.ds.Vector must always be copied to get a pointer.\n"],["target-hxcpp",null,"C++",null,"C++\nTarget summary\nFeature | Status |\nShared buffers | Yes |\nShared vectors | Yes |\nConfiguration flags\nammer.cpp.staticLink\n"],["target-hxcpp","flag-staticlink","C++","ammer.cpp.staticLink"," ammer.cpp.staticLink:Bool\nDefaults to true. Note that dynamic linking on C++ is planned, but not yet implemented.\n"],["target-cs",null,"C#",null,"C#\nTarget summary\nFeature | Status |\nShared buffers | From Haxe to native only |\nShared vectors | From Haxe to native only |\nConfiguration flags\n(no additional flags)\n"],["target-eval",null,"Eval",null,"Eval\nFeature | Status |\nShared buffers | No |\nShared vectors | No |\nConfiguration flags\n(no additional flags)\n"],["target-hashlink",null,"HashLink",null,"HashLink\nFeature | Status |\nShared buffers | Yes |\nShared vectors | Yes |\nConfiguration flags\nammer.hl.includePaths\nammer.hl.libraryPaths\n"],["target-hashlink","flag-includepaths","HashLink","ammer.hl.includePaths"," ammer.hl.includePaths:Array<String>\n"],["target-hashlink","flag-librarypaths","HashLink","ammer.hl.libraryPaths"," ammer.hl.libraryPaths:Array<String>\n"],["target-java",null,"Java",null,"Java\nFeature | Status |\nShared buffers | From Haxe to native only |\nShared vectors | From Haxe to native only |\nConfiguration flags\nammer.java.includePaths\nammer.java.libraryPaths\n"],["target-java","flag-includepaths","Java","ammer.java.includePaths"," ammer.java.includePaths:Array<String>\n"],["target-java","flag-librarypaths","Java","ammer.java.libraryPaths"," ammer.java.libraryPaths:Array<String>\n"],["target-lua",null,"Lua",null,"Lua\nFeature | Status |\nShared buffers | No |\nShared vectors | No |\nConfiguration flags\nammer.lua.includePaths\nammer.lua.libraryPaths\n"],["target-lua","flag-includepaths","Lua","ammer.lua.includePaths"," ammer.lua.includePaths:Array<String>\n"],["target-lua","flag-librarypaths","Lua","ammer.lua.libraryPaths"," ammer.lua.libraryPaths:Array<String>\n"],["target-neko",null,"Neko",null,"Neko\nFeature | Status |\nShared buffers | From Haxe to native only |\nShared vectors | No |\nConfiguration flags\nammer.neko.includePaths\nammer.neko.libraryPaths\n"],["target-neko","flag-includepaths","Neko","ammer.neko.includePaths"," ammer.neko.includePaths:Array<String>\n"],["target-neko","flag-librarypaths","Neko","ammer.neko.libraryPaths"," ammer.neko.libraryPaths:Array<String>\n"],["target-nodejs",null,"Node.js",null,"Node.js\nFeature | Status |\nShared buffers | Yes |\nShared vectors | No |\nConfiguration flags\nammer.js.nodeGypBinary\n"],["target-nodejs","flag-nodegypbinary","Node.js","ammer.js.nodeGypBinary"," ammer.js.nodeGypBinary:String\n"],["target-python",null,"Python",null,"Python\nFeature | Status |\nShared buffers | From Haxe to native only |\nShared vectors | No |\nConfiguration flags\nammer.python.version\nammer.python.includePaths\nammer.python.libraryPaths\n"],["target-python","flag-version","Python","ammer.python.version"," ammer.python.version:Int\n"],["target-python","flag-includepaths","Python","ammer.python.includePaths"," ammer.python.includePaths:Array<String>\n"],["target-python","flag-librarypaths","Python","ammer.python.libraryPaths"," ammer.python.libraryPaths:Array<String>\n"],["ref",null,"Reference",null,"Reference\nFFI types\nHaxe types do not map one-to-one to C types. Types in the ammer.ffi package are used to provide additional context.\nRead on: FFI types\nammer.def.* types\nammer definitions, such as library definitions , are declared as Haxe classes which extend one of the marker types in the ammer.def package.\nRead on: ammer.def.* types\nammer.Lib\nClient code using ammer libraries might need to perform operations which do not correspond to native library methods, but rather utility calls such as allocation.\nRead on: ammer.Lib\nList of configuration flags\nRead on: List of configuration flags\nList of annotations\nRead on: List of annotations\n"],["ref-ffi",null,"FFI types",null,"FFI types\nThis section summarises the types that can be used in definitions for function signatures and field types. The types are split into multiple categories:\nPrimitive types\nLibrary datatypes\nComposed types\nSpecial types\nStandard library types\nIn each category, the table shows the following information:\nDescription — What the type represents.\nAmmer type — How to write the type in definitions.\nHaxe call type — What the type will look like from a Haxe client of the ammer library.\nHaxe shortcut — Convenience alias for the type using an existing Haxe type, if any.\nC type — What the type maps to in a native library/in C language.\nWith a small number of exceptions, the ammer.ffi.* types exist solely for defining the types of a native library&#39;s functions or fields. When an ammer library is used from regular Haxe code, these types turn into a standard Haxe type, the conversion happens automatically. The exceptions are:\nammer.ffi.Array\nammer.ffi.Box\nammer.ffi.Bytes\nammer.ffi.Haxe\n"],["ref-ffi","primitive","FFI types","Primitive types","Primitive types\nDescription | Ammer type | Haxe call type | Haxe shortcut | C type |\nVoid | ammer.ffi.Void | Void | Void | void |\nBoolean | ammer.ffi.Bool | Bool | Bool | bool |\nUnsigned 8-bit integer | ammer.ffi.UInt8 | UInt | - | uint8_t |\nUnsigned 16-bit integer | ammer.ffi.UInt16 | UInt | - | uint16_t |\nUnsigned 32-bit integer | ammer.ffi.UInt32 | UInt | UInt | uint32_t |\nUnsigned 64-bit integer | ammer.ffi.UInt64 | UInt | - | uint64_t |\nSigned 8-bit integer | ammer.ffi.Int8 | Int | - | int8_t |\nSigned 16-bit integer | ammer.ffi.Int16 | Int | - | int16_t |\nSigned 32-bit integer | ammer.ffi.Int32 | Int | Int | int32_t |\nSigned 64-bit integer | ammer.ffi.Int64 | Int | haxe.Int64 | int64_t |\nSingle-precision IEEE 754 number | ammer.ffi.Float32 | Single 1 | Single 1 | float |\nDouble-precision IEEE 754 number | ammer.ffi.Float64 | Float | Float | double |\nString | ammer.ffi.String | String | String | const char* |\n"],["ref-ffi","fn-single","FFI types","Footnote 1: Single"," 1 : Single\nSingle is only available on some Haxe targets. When a Float32 is used on a target that does not natively support single-precision floating-points, a lossy conversion is used from 64 bits.\n"],["ref-ffi","library","FFI types","Library datatypes","Library datatypes\nDescription | Ammer type | Haxe shortcut | C type |\nOpaque pointer, struct pointer | - | T extends Struct ... | (type)* |\nOpaque data, struct | ammer.ffi.Deref<T> | T extends Struct ... | (type) |\nOpaque data, struct | ammer.ffi.Alloc<T> | T extends Struct ... | (type) |\nHaxe object | ammer.ffi.Haxe<T> | T | void* |\n"],["ref-ffi","composed","FFI types","Composed types","Composed types\nDescription | Ammer type | Haxe shortcut | C type |\nA contiguous array | ammer.ffi.Array<T> | - | (type)* |\nBox | ammer.ffi.Box<T> | - | (type)* |\nCallback | ammer.ffi.Callback<...> | - | - |\n"],["ref-ffi","special","FFI types","Special/marker types","Special/marker types\nAmmer type | Meaning |\nammer.ffi.This | Stands for the current struct instance, see instance methods |\nammer.ffi.Unsupported<...> | An unsupported type: the type parameter (a string constant) will be passed to native calls. |\n"],["ref-ffi","stdlib","FFI types","Standard library types","Standard library types\nDescription | Ammer type | C type |\nFile pointer | ammer.ffi.FilePtr | FILE* |\n"],["ref-def",null,"ammer.def.* types",null,"ammer.def.* types\nThe types in the ammer.def package are all \"marker\" types: the types themselves have no meaning and should not be used directly, but they are used as super types for ammer definitions. Any Haxe class that extends one of the types below will be processed by ammer.\n"],["ref-def","parent","ammer.def.* types","About the parent:Lib type parameter","About the parent:Lib type parameter\nThe types listed below are written with parent:Lib as a type parameter. This indicates that the type parameter should be filled in with the type name of a type that itself extends ammer.def.Library. This indicates that the given type is the \"parent\" of the one being declared. See linking subdefinitions .\n"],["ref-def","library","ammer.def.* types","ammer.def.Library"," ammer.def.Library<id:String>\nLibrary definition. See library definition for examples.\nType parameters\nid:String — The identifier used for this library. This identifier is used in the library configuration , so it must only consist of letters and underscores. It must be unique.\nAllowed fields\nStatic methods\nStatic variables\nStatic constants\nApplicable metadata\n@:ammer.lib.define\n@:ammer.lib.framework\n@:ammer.lib.frameworks\n@:ammer.lib.includePath\n@:ammer.lib.includePaths\n@:ammer.lib.language\n@:ammer.lib.libraryPath\n@:ammer.lib.libraryPaths\n@:ammer.lib.linkName\n@:ammer.lib.linkNames\n@:ammer.lib.headers.include\n@:ammer.lib.headers.import\n@:ammer.lib.headers.includeLocal\n@:ammer.lib.headers.importLocal\n@:ammer.lib.headers.includeGlobal\n@:ammer.lib.headers.importGlobal\n@:ammer.nativePrefix\n@:ammer.sub\n"],["ref-def","opaque","ammer.def.* types","ammer.def.Opaque"," ammer.def.Opaque<type:String, parent:Lib>\nOpaque type definition. See opaque type definition for examples.\nType parameters\ntype:String — The C name of this opaque type. This can be any valid C type declaration, which may contain spaces or asterisks.\nparent:Lib — parent library .\nAllowed fields\nInstance methods\nApplicable metadata\n@:ammer.nativePrefix\n"],["ref-def","struct","ammer.def.* types","ammer.def.Struct"," ammer.def.Struct<type:String, parent:Lib>\nStruct definition. See struct definition for examples.\nType parameters\ntype:String — The C name of this struct. This can be any valid C type declaration, which may contain spaces or asterisks. Note that although the type that extends ammer.def.Struct represents a pointer to the struct , the final asterisk should not be written in this type parameter.\nparent:Lib — parent library .\nAllowed fields\nInstance methods\nVariables\nApplicable metadata\n@:ammer.alloc\n@:ammer.nativePrefix\n@:ammer.sub\n@:ammer.gen.alloc\n@:ammer.gen.free\n@:ammer.gen.nullPtr\n"],["ref-def","sublibrary","ammer.def.* types","ammer.def.Sublibrary"," ammer.def.Sublibrary<parent:Lib>\nSublibrary definition. See sublibrary definition for examples.\nType parameters\nparent:Lib — parent library .\nAllowed fields\nStatic methods\nStatic variables\nStatic constants\nApplicable metadata\n@:ammer.nativePrefix\n@:ammer.sub\n"],["ref-lib",null,"ammer.Lib",null,"ammer.Lib\nThe ammer.Lib type provides a number of methods for client interaction with ammer libraries. These methods are (by necessity) macro methods. As a result, their signatures displayed below are only approximations.\n"],["ref-lib","allocstruct","ammer.Lib","ammer.Lib.allocStruct method"," ammer.Lib.allocStruct(type:Class<Struct>, ?initialValues:{ ... }):Struct\nAllocates a struct of the given type, optionally assigning the given initial values to its fields. The type must be annotated with the @:ammer.alloc metadata.\nArguments\ntype — The name (or full path) of the type to allocate.\ninitialValues — An object literal where the keys and values correspond to fields and their initial values, respectively.\n"],["ref-lib","createhaxeref","ammer.Lib","ammer.Lib.createHaxeRef method"," ammer.Lib.createHaxeRef(type:Class<T>, value:T):ammer.ffi.Haxe<T>\nCreates a reference to the given Haxe value. See Haxe types .\nArguments\ntype — The name (or full path) of the Haxe type. This is required to make sure there are no unexpected type mismatch problems e.g. when passing references to anonymous structures .\nvalue — The Haxe value to create a reference to.\n"],["ref-lib","freestruct","ammer.Lib","ammer.Lib.freeStruct method"," ammer.Lib.freeStruct(instance:Struct):Void\nDeallocates the given pointer. The type must be annotated with the @:ammer.alloc metadata.\nArguments\ninstance — The value to deallocate.\n"],["ref-lib","nullptrstruct","ammer.Lib","ammer.Lib.nullPtrStruct method"," ammer.Lib.nullPtrStruct(type:Class<Struct>):Struct\nReturns a null pointer of the given type.\nArguments\ntype — The name (or full path) of the type.\n"],["ref-flags",null,"List of configuration flags",null,"List of configuration flags\nNote that the _ after lib. in all the names below should be replaced by the identifier of the library.\nammer.buildPath\nammer.debug\nammer.outputPath\nammer.lib._.defines\nammer.lib._.frameworks\nammer.lib._.headers.includes\nammer.lib._.includePaths\nammer.lib._.language\nammer.lib._.libraryPaths\nammer.lib._.linkNames\n"],["ref-flags","buildpath","List of configuration flags","ammer.buildPath"," ammer.buildPath:String\nPath used for intermediate build artefacts. These include the C glue code generated by ammer, as well as compiled binary objects, before they are packaged into dynamic libraries. See paths .\nCompile-time defines\n-D ammer.buildPath=(string) — sets the build path.\n"],["ref-flags","debug","List of configuration flags","ammer.debug"," ammer.debug:String\nSets the debug mode for ammer. The value is a comma-separated list of categories of debug messages to show. The available categories are:\nstage\nstage-ffi\nThe flag can be set to the string all to enable all of the above.\nCompile-time defines\n-D ammer.debug=(comma-separated list) — sets the debug mode.\n"],["ref-flags","outputpath","List of configuration flags","ammer.outputPath"," ammer.outputPath:String\nPath used for final build products. These are dynamic libraries compiled by ammer that would typically be deployed with the program using them. See paths .\nCompile-time defines\n-D ammer.outputPath=(string) — sets the output path.\n"],["ref-flags","lib.defines","List of configuration flags","ammer.lib._.defines"," ammer.lib._.defines:Array<String>\nList of C preprocessor directives to set when compiling the library.\nCompile-time defines\n-D ammer.lib._.define=(string) — adds one entry to the list.\n-D ammer.lib._.defines=(comma-separated list) — adds multiple entries to the list.\nMetadata (on a library definition)\n@:ammer.lib.define(define:String) — adds one entry to the list.\n@:ammer.lib.defines(defines:Array<String>) — adds multiple entries to the list.\n"],["ref-flags","lib.frameworks","List of configuration flags","ammer.lib._.frameworks"," ammer.lib._.frameworks:Array<String>\nList of frameworks to use when compiling the library. Only has an effect on macOS.\nCompile-time defines\n-D ammer.lib._.framework=(string) — adds one entry to the list.\n-D ammer.lib._.frameworks=(comma-separated list) — adds multiple entries to the list.\nMetadata (on a library definition)\n@:ammer.lib.framework(framework:String) — adds one entry to the list.\n@:ammer.lib.frameworks(frameworks:Array<String>) — adds multiple entries to the list.\n"],["ref-flags","lib.headers","List of configuration flags","ammer.lib._.headers.includes"," ammer.lib._.headers.includes:Array<SourceInclude>\nList of headers to include when compiling the library. There are four different include styles:\nIncludeLocal — #include \"header.h\"\nIncludeGlobal — #include <header.h>\nImportLocal — #import \"header.h\"\nImportGlobal — #import <header.h>\nCompile-time defines\n-D ammer.lib._.headers=(comma-separated list) — adds multiple entries to the list, as IncludeLocals.\n-D ammer.lib._.headers.includeLocal=(string) — adds one entry to the list, as IncludeLocal.\n-D ammer.lib._.headers.includeGlobal=(string) — adds one entry to the list, as IncludeGlobal.\n-D ammer.lib._.headers.importLocal=(string) — adds one entry to the list, as ImportLocal.\n-D ammer.lib._.headers.importGlobal=(string) — adds one entry to the list, as ImportGlobal.\nMetadata (on a library definition)\n@:ammer.lib.headers.include(header:String) — adds one entry to the list, as IncludeLocal.\n@:ammer.lib.headers.import(header:String) — adds one entry to the list, as ImportLocal.\n@:ammer.lib.headers.includeLocal(header:String) — adds one entry to the list, as IncludeLocal.\n@:ammer.lib.headers.includeGlobal(header:String) — adds one entry to the list, as IncludeGlobal.\n@:ammer.lib.headers.importLocal(header:String) — adds one entry to the list, as ImportLocal.\n@:ammer.lib.headers.importGlobal(header:String) — adds one entry to the list, as ImportGlobal.\n"],["ref-flags","lib.includepaths","List of configuration flags","ammer.lib._.includePaths"," ammer.lib._.includePaths:Array<String>\nPaths to provide to the C compiler as \"include paths\", which are used when searching for header files.\nCompile-time defines\n-D ammer.lib._.includePaths=(comma-separated list) — adds multiple entries to the list.\nMetadata (on a library definition)\n@:ammer.lib.includePath(path:String) — adds one entry to the list.\n@:ammer.lib.includePaths(paths:Array<String>) — adds multiple entries to the list.\n"],["ref-flags","lib.language","List of configuration flags","ammer.lib._.language"," ammer.lib._.language:LibraryLanguage\nSpecifies the language of the native library. This language is also used for generating the glue code. Possible values:\nC - C\nCpp - C++\nObjC - Objective-C\nObjCpp - Objective-C++\nCompile-time defines\n-D ammer.lib._.language=(string) — sets the language.\nMetadata (on a library definition)\n@:ammer.lib.language(language:LibraryLanguage) — sets the language.\n"],["ref-flags","lib.librarypaths","List of configuration flags","ammer.lib._.libraryPaths"," ammer.lib._.libraryPaths:Array<String>\nPaths to provide to the C compiler (more accurately, the linker) as \"library paths\", which are used when searching for library files ( .dll, .dylib, .so files).\nCompile-time defines\n-D ammer.lib._.libraryPaths=(comma-separated list) — adds multiple entries to the list.\nMetadata (on a library definition)\n@:ammer.lib.libraryPath(path:String) — adds one entry to the list.\n@:ammer.lib.libraryPaths(paths:Array<String>) — adds multiple entries to the list.\n"],["ref-flags","lib.linknames","List of configuration flags","ammer.lib._.linkNames"," ammer.lib._.linkNames:Array<String>\nNames of libraries to link against when compiling this native library. Should not include prefixes such as -l or lib.\nCompile-time defines\n-D ammer.lib._.linkNames=(comma-separated list) — adds multiple entries to the list.\nMetadata (on a library definition)\n@:ammer.lib.linkName(path:String) — adds one entry to the list.\n@:ammer.lib.linkNames(paths:Array<String>) — adds multiple entries to the list.\n"],["ref-annot",null,"List of annotations",null,"List of annotations\nMetadata which do not correspond to a configuration flag are listed here.\n@:ammer.alloc\n@:ammer.c.cast\n@:ammer.c.macroCall\n@:ammer.c.prereturn\n@:ammer.c.return\n@:ammer.derive\n@:ammer.gen.alloc\n@:ammer.gen.free\n@:ammer.gen.nullPtr\n@:ammer.haxe\n@:ammer.native\n@:ammer.nativePrefix\n@:ammer.ret.derive\n@:ammer.skip\n@:ammer.sub\n"],["ref-annot","alloc","List of annotations","@:ammer.alloc"," @:ammer.alloc\nAllows allocation and deallocation of the annotated struct type using ammer.Lib.allocStruct and ammer.Lib.freeStruct, respectively. See allocation and deallocation .\n"],["ref-annot","c.cast","List of annotations","@:ammer.c.cast"," @:ammer.c.cast(type:String)\nMarks that the annotated argument should be cast to the given C type before being passed to the native call.\n"],["ref-annot","c.macrocall","List of annotations","@:ammer.c.macroCall"," @:ammer.c.macroCall\n(Alias: @:ammer.macroCall)\nMarks the annotated function as a macro call. See macro calls .\n"],["ref-annot","c.prereturn","List of annotations","@:ammer.c.prereturn"," @:ammer.c.prereturn(code:String)\nAdds the given C code into the native function, before the return expression. The arguments to the native call are available in the _arg0, ..., _argN local variables. See customising the C code .\n"],["ref-annot","c.return","List of annotations","@:ammer.c.return"," @:ammer.c.return(code:String)\nUses the given C expression instead of the return expression. The arguments to the native call are available in the _arg0, ..., _argN local variables. The string %CALL%, if used in code, will be replaced with the original return expression. See customising the C code .\n"],["ref-annot","derive","List of annotations","@:ammer.derive"," @:ammer.derive(e:Expr)\n"],["ref-annot","gen.alloc","List of annotations","@:ammer.gen.alloc"," @:ammer.gen.alloc(name:String)\nSpecifies the name for the generated static allocation function. See allocation and deallocation .\n"],["ref-annot","gen.free","List of annotations","@:ammer.gen.free"," @:ammer.gen.free(name:String)\nSpecifies the name for the generated instance deallocation function. See allocation and deallocation .\n"],["ref-annot","gen.nullptr","List of annotations","@:ammer.gen.nullPtr"," @:ammer.gen.nullPtr(name:String)\nSpecifies the name for the generated static null pointer function. See allocation and deallocation .\n"],["ref-annot","haxe","List of annotations","@:ammer.haxe"," @:ammer.haxe\nAllows the annotated function to have a Haxe body, skipping ammer processing. See pure Haxe functions .\n"],["ref-annot","native","List of annotations","@:ammer.native"," @:ammer.native(name:String)\nSpecifies the native name of the annotated function or field.\n"],["ref-annot","nativeprefix","List of annotations","@:ammer.nativePrefix"," @:ammer.nativePrefix(prefix:String)\nSpecifies the prefix for native names. The native name will be derived as \"prefix\" + \"the field name\", unless overridden on the field itself with @:ammer.native.\n"],["ref-annot","ret.derive","List of annotations","@:ammer.ret.derive"," @:ammer.ret.derive(e:Expr, ct:Type)\n"],["ref-annot","skip","List of annotations","@:ammer.skip"," @:ammer.skip\nMarks the given function argument to be skipped for the underlying native call.\n"],["ref-annot","sub","List of annotations","@:ammer.sub"," @:ammer.sub(sub:Type)\nMarks the given type sub as a \"subdefinition\" of the annotated library. See linking subdefinitions .\n"],["amlib",null,"amlib",null,"amlib\nTODO:\nstandard layout of amlib\nbakery defines ammer.bake\nammer.bake.mainType\nammer.bake.output\nammer.bake.rootToBin\nammer.bake.fileSource.*.name\nammer.bake.fileSource.*.downloadFrom\nammer.bake.fileSource.*.description\nammer.bake.fileSource.*.os\nammer.bake.fileSource.*.architectures\nammer.bake.fileSource.*.minVersion\nammer.bake.fileSource.*.maxVersion\n\nCI, GH action templates\nexamples of amlibs\n"],["advanced",null,"Advanced topics",null,"Advanced topics\n"],["advanced-cycles",null,"Type cycles",null,"Type cycles\nIn linking subdefinitions , it is recommended to link any library to all of its subdefinitions using the @:ammer.sub metadata. Why is this necessary?\nConsider the following types:\n// in file Foobar.hx\n@:ammer.sub((_ : FoobarStruct))\n@:ammer.sub((_ : FoobarSub))\nclass Foobar extends ammer.def.Library<\"foobar\"> {\n public static function some_function():FoobarStruct;\n}\n\n// in file FoobarStruct.hx\nclass FoobarStruct extends ammer.def.Struct<\"foobar_t\", Foobar> {\n // ...\n}\n\n// in file FoobarSub.hx\nclass FoobarSub extends ammer.def.Sublibrary<Foobar> {\n public static function another_function():Void;\n}\nBetween Foobar and FoobarSub, there is a two-way link:\n@:ammer.sub((_ : FoobarSub)) — Links the library to the subdefinition.\n... extends ammer.def.Sublibrary<Foobar> — Links the subdefinition to the library.\nIf the @:ammer.sub((_ : FoobarSub)) annotation was omitted, then the following client code could cause a compilation failure:\nFoobar.some_function();\nFoobarSub.another_function();\nThis is because Haxe performs typing on demand: the Foobar module (in the file Foobar.hx) is not discovered and typed until the first time it is needed. This can happen if a type (and its static method) declared in that module is used, as in the first line.\nHowever, Foobar is not a regular Haxe type: it is an ammer-annotated library definition. When an ammer library is typed, the following steps take place (simplified):\nA library context is established, containing the library configuration etc.\nAll fields of the library are eagerly typed. This may trigger transitive typing. In the example above, this leads Haxe to discover the FoobarStruct type, because it is used as the return type of one of the methods of Foobar.\nThe library is finalised by writing the required glue code into a file, which will later be compiled by a C compiler.\nWithout the @:ammer.sub((_ : FoobarSub)) annotation on Foobar, the first line of the client only causes the Haxe compiler to discover Foobar and FoobarStruct. When typing the second line (the call to FoobarSub.another_function), FoobarSub is discovered, but it cannot be added to Foobar anymore: the library was finalised and the glue code was already generated.\nThe safe recommendation is therefore to always use @:ammer.sub, even when other fields would cause the Haxe compiler to discover the subdefinitions.\n"],["core",null,"ammer-core",null,"ammer-core\nammer-core is a macro library that forms the foundation of ammer. Its main function is to allow each ammer target to be compiled and linked to C functions. To achieve this:\nFor each ammer target: It generates code that contains the C functions, along with any glue code required by the target&#39;s FFI mechanism.\nIn each function, it marshals data from the target&#39;s native representation to its C counterparts.\nIt defines a sequence of build steps that compiles the generated glue code, including any headers and dynamic libraries required by the target&#39;s FFI mechanism.\n\nFor each build system: It executes the sequence of build steps by invoking the concrete compiler/linker with appropriate arguments.\n\nThe API of ammer-core is quite low-level and stays quite close to the C counterparts. Notably, ammer-core does not map Haxe classes and types to native libraries, it does not assume that there is a single dynamic library being defined, and it does not process metadata or defines: these are all handled by ammer.\n"],["core-api",null,"Interface",null,"Interface\nThe main points of interaction with ammer-core are:\nammer.core.Platform (and concrete implementations in ammer.core.plat.*),\nammer.core.Library,\nammer.core.Marshal, and\nammer.core.Builder (and concrete implementations in ammer.core.build.*).\n"],["core-api","platform","Interface","`Platform`"," Platform\nA Platform represents one of ammer/ ammer-core targets. It can be constructed by calling ammer.core.Platform.createCurrentPlatform, or by directly calling a constructor of one of the ammer.core.plat.* types. The constructor takes a platform configuration, which is a class that contains at least the fields defined in ammer.core.plat.BaseConfig, but may contain more (required) fields: see ammer.core.plat.(Platform).(Platform)Config.\nPlatforms are used to create libraries with the createLibrary method. Once a library is finished (all its types and functions are declared), it is given to the platform with addLibrary. Finally, the finalise method returns a build program to be used by the builder .\n"],["core-api","library","Interface","`Library`"," Library\nA Library represents a set of types and functions that will be compiled as one unit into a dynamic library ( .dll, .dylib, .so).\nAs mentioned above, a Library is obtained from a platform using createLibrary: this function takes a library configuration object. This is a class that contains at least the fields defined in ammer.core.LibraryConfig, but platforms may add more fields, see ammer.core.plat.(Platform).(Platform)LibraryConfig.\nLibraries contain a reference to a marshal object, and can have code added to them using these functions:\naddInclude, addCode, addHeaderCode — add code directly.\naddFunction — adds a function with the given signature and body which can be called from Haxe using the returned expression.\naddCallback, addStaticCallback — add functions forwarding calls to Haxe closures (or static methods, respectively) that can be called from native code using the returned name. The code provided to these functions will often make use of the closureCall and staticCall functions, which performs the actual call to a Haxe closure, given its reference.\n"],["core-api","marshal","Interface","`Marshal`"," Marshal\nMarshal is the class that defines how values are marshalled (passed through) between Haxe and C. It has methods for each kind of type that ammer-core understands. These methods return instances of TypeMarshal, which can then be passed to functions such as addFunction to define signatures of functions.\n"],["core-api","builder","Interface","`Builder`"," Builder\nA Builder represents a build system, such as GCC or MSVC, that is used to execute the build steps returned by finalising a platform, with the build function.\n"],["core-new-platform",null,"Implementing new platforms",null,"Implementing new platforms\nAbout type representation\nInstances of TypeMarshal (obtained from a Marshal instance ) define how any given type is to be passed between Haxe and C. This marshalling is performed in up to three steps in C code (depending on the concrete platform and type), named L1 (closest to Haxe and the concrete Haxe target), L2, and L3 (unified C representation).\nhaxeType — the ComplexType used for this type in calls from Haxe.\nmangled — a short representation of the type, used in identifiers and mangled function signatures.\nl1Type, l2Type, l3Type — the C type at each step.\nl1l2, l2l3, l3l2, l2l1 — functions which output the C code that transforms the value from one level to another. For example, l1l2 is given as first argument an expression representing the L1 representation, as second argument an identifier to which the L2 representation will be written, and returns the code that performs e.g. (l2) = transform((l1));. The generated code may span multiple lines and may require multiple method calls interacting with the current platform&#39;s FFI mechanism.\nImplementing the platform file\nTo create a new Platform, it is best to follow examples of existing platforms, whose implementations are in the ammer.core.plat package. There is also a None platform which performs no-ops or raises exceptions for all of its operations; it can also serve as a good template file for new platform implementations.\nTypes such as ammer.core.Platform and ammer.core.PlatformId should also be adapted to make ammer-core aware of the new platform.\nWhen developing the actual implementation, a rough guideline is as follow:\nStart with outputting any C glue code.\nImplement addNamedFunction (with dummy arguments at first).\nImplement types in Marshal, enabling tests one at a time. The simplest test is probably TestBools, requiring only the Bool type marshalling to work.\n\nImplement the finalise steps to get a dynamic library that actually compiles and links against the target&#39;s FFI mechanism.\nEnable and pass the other tests: integers, TestIntegers.hx\nfloats, TestFloats.hx\nopaques, part of TestStructs.hx\nstructs, rest of TestStructs.hx\nbytes, TestBytes.hx\narrays, Haxe values, callbacks ...\n\nPlatform configuration, polish.\n"]]